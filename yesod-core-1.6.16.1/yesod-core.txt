-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Creation of type-safe, RESTful web applications.
--   
--   API docs and the README are available at
--   <a>http://www.stackage.org/package/yesod-core</a>
@package yesod-core
@version 1.6.16.1

module Yesod.Core.Types
type SessionMap = Map Text ByteString
type SaveSession = SessionMap " The session contents after running the handler" -> IO [Header]
newtype SessionBackend
SessionBackend :: (Request -> IO (SessionMap, SaveSession)) -> SessionBackend

-- | Return the session data and a function to save the session
[sbLoadSession] :: SessionBackend -> Request -> IO (SessionMap, SaveSession)
data SessionCookie
SessionCookie :: !Either UTCTime ByteString -> !ByteString -> !SessionMap -> SessionCookie
data ClientSessionDateCache
ClientSessionDateCache :: !UTCTime -> !UTCTime -> !ByteString -> ClientSessionDateCache
[csdcNow] :: ClientSessionDateCache -> !UTCTime
[csdcExpires] :: ClientSessionDateCache -> !UTCTime
[csdcExpiresSerialized] :: ClientSessionDateCache -> !ByteString

-- | The parsed request information. This type augments the standard WAI
--   <a>Request</a> with additional information.
data YesodRequest
YesodRequest :: ![(Text, Text)] -> ![(Text, Text)] -> !Request -> ![Text] -> !Maybe Text -> !SessionMap -> ![ContentType] -> YesodRequest

-- | Same as <a>queryString</a>, but decoded to <tt>Text</tt>.
[reqGetParams] :: YesodRequest -> ![(Text, Text)]
[reqCookies] :: YesodRequest -> ![(Text, Text)]
[reqWaiRequest] :: YesodRequest -> !Request

-- | Languages which the client supports. This is an ordered list by
--   preference.
[reqLangs] :: YesodRequest -> ![Text]

-- | A random, session-specific token used to prevent CSRF attacks.
[reqToken] :: YesodRequest -> !Maybe Text

-- | Initial session sent from the client.
--   
--   Since 1.2.0
[reqSession] :: YesodRequest -> !SessionMap

-- | An ordered list of the accepted content types.
--   
--   Since 1.2.0
[reqAccept] :: YesodRequest -> ![ContentType]

-- | An augmented WAI <a>Response</a>. This can either be a standard
--   <tt>Response</tt>, or a higher-level data structure which Yesod will
--   turn into a <tt>Response</tt>.
data YesodResponse
YRWai :: !Response -> YesodResponse
YRWaiApp :: !Application -> YesodResponse
YRPlain :: !Status -> ![Header] -> !ContentType -> !Content -> !SessionMap -> YesodResponse

-- | A tuple containing both the POST parameters and submitted files.
type RequestBodyContents = ([(Text, Text)], [(Text, FileInfo)])
data FileInfo
FileInfo :: !Text -> !Text -> !ConduitT () ByteString (ResourceT IO) () -> !FilePath -> IO () -> FileInfo
[fileName] :: FileInfo -> !Text
[fileContentType] :: FileInfo -> !Text
[fileSourceRaw] :: FileInfo -> !ConduitT () ByteString (ResourceT IO) ()
[fileMove] :: FileInfo -> !FilePath -> IO ()
data FileUpload
FileUploadMemory :: !BackEnd ByteString -> FileUpload
FileUploadDisk :: !InternalState -> BackEnd FilePath -> FileUpload
FileUploadSource :: !BackEnd (ConduitT () ByteString (ResourceT IO) ()) -> FileUpload

-- | How to determine the root of the application for constructing URLs.
--   
--   Note that future versions of Yesod may add new constructors without
--   bumping the major version number. As a result, you should <i>not</i>
--   pattern match on <tt>Approot</tt> values.
data Approot master

-- | No application root.
ApprootRelative :: Approot master
ApprootStatic :: !Text -> Approot master
ApprootMaster :: !master -> Text -> Approot master
ApprootRequest :: !master -> Request -> Text -> Approot master
type ResolvedApproot = Text
data AuthResult
Authorized :: AuthResult
AuthenticationRequired :: AuthResult
Unauthorized :: !Text -> AuthResult
data ScriptLoadPosition master
BottomOfBody :: ScriptLoadPosition master
BottomOfHeadBlocking :: ScriptLoadPosition master
BottomOfHeadAsync :: !BottomOfHeadAsync master -> ScriptLoadPosition master
type BottomOfHeadAsync master = [Text] " urls to load asynchronously" -> Maybe (HtmlUrl (Route master)) " widget of js to run on async completion" -> HtmlUrl (Route master) " widget to insert at the bottom of <head>"
type Texts = [Text]

-- | Wrap up a normal WAI application as a Yesod subsite. Ignore parent
--   site's middleware and isAuthorized.
newtype WaiSubsite
WaiSubsite :: Application -> WaiSubsite
[runWaiSubsite] :: WaiSubsite -> Application

-- | Like <a>WaiSubsite</a>, but applies parent site's middleware and
--   isAuthorized.
newtype WaiSubsiteWithAuth
WaiSubsiteWithAuth :: Application -> WaiSubsiteWithAuth
[runWaiSubsiteWithAuth] :: WaiSubsiteWithAuth -> Application
data RunHandlerEnv child site
RunHandlerEnv :: !Route site -> [(Text, Text)] -> Text -> !Maybe (Route child) -> !Route child -> Route site -> !site -> !child -> !RequestBodyLength -> FileUpload -> !Loc -> LogSource -> LogLevel -> LogStr -> IO () -> !ErrorResponse -> YesodApp -> !Text -> RunHandlerEnv child site
[rheRender] :: RunHandlerEnv child site -> !Route site -> [(Text, Text)] -> Text
[rheRoute] :: RunHandlerEnv child site -> !Maybe (Route child)
[rheRouteToMaster] :: RunHandlerEnv child site -> !Route child -> Route site
[rheSite] :: RunHandlerEnv child site -> !site
[rheChild] :: RunHandlerEnv child site -> !child
[rheUpload] :: RunHandlerEnv child site -> !RequestBodyLength -> FileUpload
[rheLog] :: RunHandlerEnv child site -> !Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | How to respond when an error is thrown internally.
--   
--   Since 1.2.0
[rheOnError] :: RunHandlerEnv child site -> !ErrorResponse -> YesodApp
[rheMaxExpires] :: RunHandlerEnv child site -> !Text
data HandlerData child site
HandlerData :: !YesodRequest -> !RunHandlerEnv child site -> !IORef GHState -> !InternalState -> HandlerData child site
[handlerRequest] :: HandlerData child site -> !YesodRequest
[handlerEnv] :: HandlerData child site -> !RunHandlerEnv child site
[handlerState] :: HandlerData child site -> !IORef GHState
[handlerResource] :: HandlerData child site -> !InternalState
data YesodRunnerEnv site
YesodRunnerEnv :: !Logger -> !site -> !Maybe SessionBackend -> !IO Int -> !IO Text -> YesodRunnerEnv site
[yreLogger] :: YesodRunnerEnv site -> !Logger
[yreSite] :: YesodRunnerEnv site -> !site
[yreSessionBackend] :: YesodRunnerEnv site -> !Maybe SessionBackend

-- | Generate a random number
[yreGen] :: YesodRunnerEnv site -> !IO Int
[yreGetMaxExpires] :: YesodRunnerEnv site -> !IO Text
data YesodSubRunnerEnv sub parent
YesodSubRunnerEnv :: !ParentRunner parent -> !parent -> sub -> !Route sub -> Route parent -> !YesodRunnerEnv parent -> YesodSubRunnerEnv sub parent
[ysreParentRunner] :: YesodSubRunnerEnv sub parent -> !ParentRunner parent
[ysreGetSub] :: YesodSubRunnerEnv sub parent -> !parent -> sub
[ysreToParentRoute] :: YesodSubRunnerEnv sub parent -> !Route sub -> Route parent
[ysreParentEnv] :: YesodSubRunnerEnv sub parent -> !YesodRunnerEnv parent
type ParentRunner parent = HandlerFor parent TypedContent -> YesodRunnerEnv parent -> Maybe (Route parent) -> Application

-- | A generic handler monad, which can have a different subsite and master
--   site. We define a newtype for better error message.
newtype HandlerFor site a
HandlerFor :: (HandlerData site site -> IO a) -> HandlerFor site a
[unHandlerFor] :: HandlerFor site a -> HandlerData site site -> IO a
data GHState
GHState :: !SessionMap -> !Maybe RequestBodyContents -> !Int -> !TypeMap -> !KeyedTypeMap -> !Endo [Header] -> GHState
[ghsSession] :: GHState -> !SessionMap
[ghsRBC] :: GHState -> !Maybe RequestBodyContents
[ghsIdent] :: GHState -> !Int
[ghsCache] :: GHState -> !TypeMap
[ghsCacheBy] :: GHState -> !KeyedTypeMap
[ghsHeaders] :: GHState -> !Endo [Header]

-- | An extension of the basic WAI <a>Application</a> datatype to provide
--   extra features needed by Yesod. Users should never need to use this
--   directly, as the <tt>HandlerT</tt> monad and template haskell code
--   should hide it away.
type YesodApp = YesodRequest -> ResourceT IO YesodResponse

-- | A generic widget, allowing specification of both the subsite and
--   master site datatypes. While this is simply a <tt>WriterT</tt>, we
--   define a newtype for better error messages.
newtype WidgetFor site a
WidgetFor :: (WidgetData site -> IO a) -> WidgetFor site a
[unWidgetFor] :: WidgetFor site a -> WidgetData site -> IO a
data WidgetData site
WidgetData :: {-# UNPACK #-} !IORef (GWData (Route site)) -> {-# UNPACK #-} !HandlerData site site -> WidgetData site
[wdRef] :: WidgetData site -> {-# UNPACK #-} !IORef (GWData (Route site))
[wdHandler] :: WidgetData site -> {-# UNPACK #-} !HandlerData site site
tellWidget :: GWData (Route site) -> WidgetFor site ()
type RY master = Route master -> [(Text, Text)] -> Text

-- | Newtype wrapper allowing injection of arbitrary content into CSS.
--   
--   Usage:
--   
--   <pre>
--   toWidget $ CssBuilder "p { color: red }"
--   </pre>
--   
--   Since: 1.1.3
newtype CssBuilder
CssBuilder :: Builder -> CssBuilder
[unCssBuilder] :: CssBuilder -> Builder

-- | Content for a web page. By providing this datatype, we can easily
--   create generic site templates, which would have the type signature:
--   
--   <pre>
--   PageContent url -&gt; HtmlUrl url
--   </pre>
data PageContent url
PageContent :: !Html -> !HtmlUrl url -> !HtmlUrl url -> PageContent url
[pageTitle] :: PageContent url -> !Html
[pageHead] :: PageContent url -> !HtmlUrl url
[pageBody] :: PageContent url -> !HtmlUrl url
data Content

-- | The content and optional content length.
ContentBuilder :: !Builder -> !Maybe Int -> Content
ContentSource :: !ConduitT () (Flush Builder) (ResourceT IO) () -> Content
ContentFile :: !FilePath -> !Maybe FilePart -> Content
ContentDontEvaluate :: !Content -> Content
data TypedContent
TypedContent :: !ContentType -> !Content -> TypedContent

-- | <i>Deprecated: Please use Html instead</i>
type RepHtml = Html
newtype RepJson
RepJson :: Content -> RepJson
newtype RepPlain
RepPlain :: Content -> RepPlain
newtype RepXml
RepXml :: Content -> RepXml
type ContentType = ByteString

-- | Wrapper around types so that Handlers can return a domain type, even
--   when the data will eventually be encoded as JSON. Example usage in a
--   type signature:
--   
--   <pre>
--   postSignupR :: Handler (JSONResponse CreateUserResponse)
--   </pre>
--   
--   And in the implementation:
--   
--   <pre>
--   return $ JSONResponse $ CreateUserResponse userId
--   </pre>
data JSONResponse a
[JSONResponse] :: ToJSON a => a -> JSONResponse a

-- | Prevents a response body from being fully evaluated before sending the
--   request.
--   
--   Since 1.1.0
newtype DontFullyEvaluate a
DontFullyEvaluate :: a -> DontFullyEvaluate a
[unDontFullyEvaluate] :: DontFullyEvaluate a -> a

-- | Responses to indicate some form of an error occurred.
data ErrorResponse
NotFound :: ErrorResponse
InternalError :: !Text -> ErrorResponse
InvalidArgs :: ![Text] -> ErrorResponse
NotAuthenticated :: ErrorResponse
PermissionDenied :: !Text -> ErrorResponse
BadMethod :: !Method -> ErrorResponse

-- | Headers to be added to a <tt>Result</tt>.
data Header
AddCookie :: !SetCookie -> Header

-- | name and path
DeleteCookie :: !ByteString -> !ByteString -> Header

-- | key and value
Header :: !CI ByteString -> !ByteString -> Header
data Location url
Local :: !url -> Location url
Remote :: !Text -> Location url

-- | A diff list that does not directly enforce uniqueness. When creating a
--   widget Yesod will use nub to make it unique.
newtype UniqueList x
UniqueList :: ([x] -> [x]) -> UniqueList x
data Script url
Script :: !Location url -> ![(Text, Text)] -> Script url
[scriptLocation] :: Script url -> !Location url
[scriptAttributes] :: Script url -> ![(Text, Text)]
data Stylesheet url
Stylesheet :: !Location url -> ![(Text, Text)] -> Stylesheet url
[styleLocation] :: Stylesheet url -> !Location url
[styleAttributes] :: Stylesheet url -> ![(Text, Text)]
newtype Title
Title :: Html -> Title
[unTitle] :: Title -> Html
newtype Head url
Head :: HtmlUrl url -> Head url
newtype Body url
Body :: HtmlUrl url -> Body url
type CssBuilderUrl a = (a -> [(Text, Text)] -> Text) -> Builder
data GWData a
GWData :: !Body a -> !Last Title -> !UniqueList (Script a) -> !UniqueList (Stylesheet a) -> !Map (Maybe Text) (CssBuilderUrl a) -> !Maybe (JavascriptUrl a) -> !Head a -> GWData a
[gwdBody] :: GWData a -> !Body a
[gwdTitle] :: GWData a -> !Last Title
[gwdScripts] :: GWData a -> !UniqueList (Script a)
[gwdStylesheets] :: GWData a -> !UniqueList (Stylesheet a)
[gwdCss] :: GWData a -> !Map (Maybe Text) (CssBuilderUrl a)
[gwdJavascript] :: GWData a -> !Maybe (JavascriptUrl a)
[gwdHead] :: GWData a -> !Head a
data HandlerContents
HCContent :: !Status -> !TypedContent -> HandlerContents
HCError :: !ErrorResponse -> HandlerContents
HCSendFile :: !ContentType -> !FilePath -> !Maybe FilePart -> HandlerContents
HCRedirect :: !Status -> !Text -> HandlerContents
HCCreated :: !Text -> HandlerContents
HCWai :: !Response -> HandlerContents
HCWaiApp :: !Application -> HandlerContents
data Logger
Logger :: !LoggerSet -> !DateCacheGetter -> Logger
[loggerSet] :: Logger -> !LoggerSet
[loggerDate] :: Logger -> !DateCacheGetter
loggerPutStr :: Logger -> LogStr -> IO ()

-- | A handler monad for subsite
newtype SubHandlerFor sub master a
SubHandlerFor :: (HandlerData sub master -> IO a) -> SubHandlerFor sub master a
[unSubHandlerFor] :: SubHandlerFor sub master a -> HandlerData sub master -> IO a
instance GHC.Base.Functor (Yesod.Core.Types.SubHandlerFor sub master)
instance GHC.Base.Functor (Yesod.Core.Types.WidgetFor site)
instance GHC.Base.Monoid (Yesod.Core.Types.Body url)
instance GHC.Base.Monoid (Yesod.Core.Types.Head url)
instance GHC.Classes.Eq url => GHC.Classes.Eq (Yesod.Core.Types.Stylesheet url)
instance GHC.Show.Show url => GHC.Show.Show (Yesod.Core.Types.Stylesheet url)
instance GHC.Classes.Eq url => GHC.Classes.Eq (Yesod.Core.Types.Script url)
instance GHC.Show.Show url => GHC.Show.Show (Yesod.Core.Types.Script url)
instance GHC.Classes.Eq url => GHC.Classes.Eq (Yesod.Core.Types.Location url)
instance GHC.Show.Show url => GHC.Show.Show (Yesod.Core.Types.Location url)
instance GHC.Base.Functor (Yesod.Core.Types.HandlerFor site)
instance GHC.Show.Show Yesod.Core.Types.Header
instance GHC.Classes.Eq Yesod.Core.Types.Header
instance GHC.Generics.Generic Yesod.Core.Types.ErrorResponse
instance GHC.Classes.Eq Yesod.Core.Types.ErrorResponse
instance GHC.Show.Show Yesod.Core.Types.ErrorResponse
instance GHC.Read.Read Yesod.Core.Types.AuthResult
instance GHC.Show.Show Yesod.Core.Types.AuthResult
instance GHC.Classes.Eq Yesod.Core.Types.AuthResult
instance GHC.Show.Show Yesod.Core.Types.ClientSessionDateCache
instance GHC.Classes.Eq Yesod.Core.Types.ClientSessionDateCache
instance GHC.Read.Read Yesod.Core.Types.SessionCookie
instance GHC.Show.Show Yesod.Core.Types.SessionCookie
instance GHC.Classes.Ord (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsite)
instance GHC.Read.Read (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsite)
instance GHC.Classes.Eq (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsite)
instance GHC.Show.Show (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsite)
instance GHC.Classes.Ord (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsiteWithAuth)
instance GHC.Read.Read (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsiteWithAuth)
instance GHC.Classes.Eq (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsiteWithAuth)
instance GHC.Show.Show (Yesod.Routes.Class.Route Yesod.Core.Types.WaiSubsiteWithAuth)
instance GHC.Base.Applicative (Yesod.Core.Types.SubHandlerFor child master)
instance GHC.Base.Monad (Yesod.Core.Types.SubHandlerFor child master)
instance Control.Monad.IO.Class.MonadIO (Yesod.Core.Types.SubHandlerFor child master)
instance Control.Monad.Reader.Class.MonadReader (Yesod.Core.Types.HandlerData child master) (Yesod.Core.Types.SubHandlerFor child master)
instance Control.Monad.IO.Unlift.MonadUnliftIO (Yesod.Core.Types.SubHandlerFor child master)
instance Control.Monad.Catch.MonadThrow (Yesod.Core.Types.SubHandlerFor child master)
instance Control.Monad.Trans.Resource.Internal.MonadResource (Yesod.Core.Types.SubHandlerFor child master)
instance Control.Monad.Logger.MonadLogger (Yesod.Core.Types.SubHandlerFor child master)
instance Control.Monad.Logger.MonadLoggerIO (Yesod.Core.Types.SubHandlerFor child master)
instance GHC.Show.Show Yesod.Core.Types.HandlerContents
instance GHC.Exception.Type.Exception Yesod.Core.Types.HandlerContents
instance (a Data.Type.Equality.~ ()) => GHC.Base.Monoid (Yesod.Core.Types.WidgetFor site a)
instance (a Data.Type.Equality.~ ()) => GHC.Base.Semigroup (Yesod.Core.Types.WidgetFor site a)
instance (a Data.Type.Equality.~ ()) => Data.String.IsString (Yesod.Core.Types.WidgetFor site a)
instance GHC.Base.Applicative (Yesod.Core.Types.WidgetFor site)
instance GHC.Base.Monad (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.IO.Class.MonadIO (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.Primitive.PrimMonad (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.IO.Unlift.MonadUnliftIO (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.Reader.Class.MonadReader (Yesod.Core.Types.WidgetData site) (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.Catch.MonadThrow (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.Trans.Resource.Internal.MonadResource (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.Logger.MonadLogger (Yesod.Core.Types.WidgetFor site)
instance Control.Monad.Logger.MonadLoggerIO (Yesod.Core.Types.WidgetFor site)
instance GHC.Base.Monoid (Yesod.Core.Types.GWData a)
instance GHC.Base.Semigroup (Yesod.Core.Types.GWData a)
instance GHC.Base.Semigroup (Yesod.Core.Types.Body url)
instance GHC.Base.Semigroup (Yesod.Core.Types.Head url)
instance GHC.Base.Monoid (Yesod.Core.Types.UniqueList x)
instance GHC.Base.Semigroup (Yesod.Core.Types.UniqueList x)
instance GHC.Base.Applicative (Yesod.Core.Types.HandlerFor site)
instance GHC.Base.Monad (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.IO.Class.MonadIO (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.Primitive.PrimMonad (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.Reader.Class.MonadReader (Yesod.Core.Types.HandlerData site site) (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.IO.Unlift.MonadUnliftIO (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.Catch.MonadThrow (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.Trans.Resource.Internal.MonadResource (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.Logger.MonadLogger (Yesod.Core.Types.HandlerFor site)
instance Control.Monad.Logger.MonadLoggerIO (Yesod.Core.Types.HandlerFor site)
instance Control.DeepSeq.NFData Yesod.Core.Types.Header
instance Control.DeepSeq.NFData Yesod.Core.Types.ErrorResponse
instance Data.String.IsString Yesod.Core.Types.Content
instance Yesod.Routes.Class.RenderRoute Yesod.Core.Types.WaiSubsiteWithAuth
instance Yesod.Routes.Class.ParseRoute Yesod.Core.Types.WaiSubsiteWithAuth
instance Yesod.Routes.Class.RenderRoute Yesod.Core.Types.WaiSubsite
instance Yesod.Routes.Class.ParseRoute Yesod.Core.Types.WaiSubsite
instance Data.Serialize.Serialize Yesod.Core.Types.SessionCookie

module Yesod.Core.Content
data Content

-- | The content and optional content length.
ContentBuilder :: !Builder -> !Maybe Int -> Content
ContentSource :: !ConduitT () (Flush Builder) (ResourceT IO) () -> Content
ContentFile :: !FilePath -> !Maybe FilePart -> Content
ContentDontEvaluate :: !Content -> Content

-- | Zero-length enumerator.
emptyContent :: Content

-- | Anything which can be converted into <a>Content</a>. Most of the time,
--   you will want to use the <a>ContentBuilder</a> constructor. An easier
--   approach will be to use a pre-defined <a>toContent</a> function, such
--   as converting your data into a lazy bytestring and then calling
--   <a>toContent</a> on that.
--   
--   Please note that the built-in instances for lazy data structures
--   (<a>String</a>, lazy <a>ByteString</a>, lazy <a>Text</a> and
--   <a>Html</a>) will not automatically include the content length for the
--   <a>ContentBuilder</a> constructor.
class ToContent a
toContent :: ToContent a => a -> Content

-- | A class for all data which can be sent in a streaming response. Note
--   that for textual data, instances must use UTF-8 encoding.
--   
--   Since 1.2.0
class ToFlushBuilder a
toFlushBuilder :: ToFlushBuilder a => a -> Flush Builder
type ContentType = ByteString
typeHtml :: ContentType
typePlain :: ContentType
typeJson :: ContentType
typeXml :: ContentType
typeAtom :: ContentType
typeRss :: ContentType
typeJpeg :: ContentType
typePng :: ContentType
typeGif :: ContentType
typeSvg :: ContentType
typeJavascript :: ContentType
typeCss :: ContentType
typeFlv :: ContentType
typeOgv :: ContentType
typeOctet :: ContentType

-- | Removes "extra" information at the end of a content type string. In
--   particular, removes everything after the semicolon, if present.
--   
--   For example, "text/html; charset=utf-8" is commonly used to specify
--   the character encoding for HTML data. This function would return
--   "text/html".
simpleContentType :: ContentType -> ContentType

-- | Give just the media types as a pair.
--   
--   For example, "text/html; charset=utf-8" returns ("text", "html")
contentTypeTypes :: ContentType -> (ByteString, ByteString)

-- | Prevents a response body from being fully evaluated before sending the
--   request.
--   
--   Since 1.1.0
newtype DontFullyEvaluate a
DontFullyEvaluate :: a -> DontFullyEvaluate a
[unDontFullyEvaluate] :: DontFullyEvaluate a -> a
data TypedContent
TypedContent :: !ContentType -> !Content -> TypedContent

-- | Any type which can be converted to <a>TypedContent</a>.
--   
--   Since 1.2.0
class ToContent a => ToTypedContent a
toTypedContent :: ToTypedContent a => a -> TypedContent
class ToTypedContent a => HasContentType a
getContentType :: (HasContentType a, Monad m) => m a -> ContentType

-- | <i>Deprecated: Please use Html instead</i>
type RepHtml = Html
newtype RepJson
RepJson :: Content -> RepJson
newtype RepPlain
RepPlain :: Content -> RepPlain
newtype RepXml
RepXml :: Content -> RepXml
repJson :: ToContent a => a -> RepJson
repPlain :: ToContent a => a -> RepPlain
repXml :: ToContent a => a -> RepXml
instance Yesod.Core.Content.ToContent Yesod.Core.Types.RepJson
instance Yesod.Core.Content.ToContent Yesod.Core.Types.RepPlain
instance Yesod.Core.Content.ToContent Yesod.Core.Types.RepXml
instance Yesod.Core.Content.HasContentType Yesod.Core.Types.RepJson
instance Yesod.Core.Content.HasContentType Yesod.Core.Types.RepPlain
instance Yesod.Core.Content.HasContentType (Yesod.Core.Types.JSONResponse a)
instance Yesod.Core.Content.HasContentType Yesod.Core.Types.RepXml
instance Yesod.Core.Content.HasContentType a => Yesod.Core.Content.HasContentType (Yesod.Core.Types.DontFullyEvaluate a)
instance Yesod.Core.Content.HasContentType Data.Aeson.Types.Internal.Value
instance Yesod.Core.Content.HasContentType Data.Aeson.Encoding.Internal.Encoding
instance Yesod.Core.Content.HasContentType Text.Blaze.Html.Html
instance Yesod.Core.Content.HasContentType Data.Text.Internal.Lazy.Text
instance Yesod.Core.Content.HasContentType Data.Text.Internal.Text
instance Yesod.Core.Content.HasContentType Text.Internal.Css.Css
instance Yesod.Core.Content.HasContentType Text.Julius.Javascript
instance Yesod.Core.Content.ToTypedContent Yesod.Core.Types.TypedContent
instance Yesod.Core.Content.ToTypedContent ()
instance Yesod.Core.Content.ToTypedContent (Yesod.Core.Types.ContentType, Yesod.Core.Types.Content)
instance Yesod.Core.Content.ToTypedContent Yesod.Core.Types.RepJson
instance Yesod.Core.Content.ToTypedContent Yesod.Core.Types.RepPlain
instance Yesod.Core.Content.ToTypedContent Yesod.Core.Types.RepXml
instance Yesod.Core.Content.ToTypedContent Data.Aeson.Types.Internal.Value
instance Yesod.Core.Content.ToTypedContent Data.Aeson.Encoding.Internal.Encoding
instance Yesod.Core.Content.ToTypedContent Text.Blaze.Html.Html
instance Yesod.Core.Content.ToTypedContent Data.Text.Internal.Text
instance Yesod.Core.Content.ToTypedContent [GHC.Types.Char]
instance Yesod.Core.Content.ToTypedContent Data.Text.Internal.Lazy.Text
instance Yesod.Core.Content.ToTypedContent (Yesod.Core.Types.JSONResponse a)
instance Yesod.Core.Content.ToTypedContent a => Yesod.Core.Content.ToTypedContent (Yesod.Core.Types.DontFullyEvaluate a)
instance Yesod.Core.Content.ToTypedContent Text.Internal.Css.Css
instance Yesod.Core.Content.ToTypedContent Text.Julius.Javascript
instance Yesod.Core.Content.ToFlushBuilder builder => Yesod.Core.Content.ToContent (Data.Conduit.Internal.Pipe.Pipe () () builder () (Control.Monad.Trans.Resource.Internal.ResourceT GHC.Types.IO) ())
instance Yesod.Core.Content.ToFlushBuilder builder => Yesod.Core.Content.ToContent (Data.Conduit.Internal.Conduit.ConduitT () builder (Control.Monad.Trans.Resource.Internal.ResourceT GHC.Types.IO) ())
instance Yesod.Core.Content.ToFlushBuilder builder => Yesod.Core.Content.ToContent (Data.Conduit.Internal.Conduit.SealedConduitT () builder (Control.Monad.Trans.Resource.Internal.ResourceT GHC.Types.IO) ())
instance Yesod.Core.Content.ToFlushBuilder (Data.Conduit.Internal.Conduit.Flush Data.ByteString.Builder.Internal.Builder)
instance Yesod.Core.Content.ToFlushBuilder Data.ByteString.Builder.Internal.Builder
instance Yesod.Core.Content.ToFlushBuilder (Data.Conduit.Internal.Conduit.Flush Data.ByteString.Internal.ByteString)
instance Yesod.Core.Content.ToFlushBuilder Data.ByteString.Internal.ByteString
instance Yesod.Core.Content.ToFlushBuilder (Data.Conduit.Internal.Conduit.Flush Data.ByteString.Lazy.Internal.ByteString)
instance Yesod.Core.Content.ToFlushBuilder Data.ByteString.Lazy.Internal.ByteString
instance Yesod.Core.Content.ToFlushBuilder (Data.Conduit.Internal.Conduit.Flush Data.Text.Internal.Lazy.Text)
instance Yesod.Core.Content.ToFlushBuilder Data.Text.Internal.Lazy.Text
instance Yesod.Core.Content.ToFlushBuilder (Data.Conduit.Internal.Conduit.Flush Data.Text.Internal.Text)
instance Yesod.Core.Content.ToFlushBuilder Data.Text.Internal.Text
instance Yesod.Core.Content.ToFlushBuilder (Data.Conduit.Internal.Conduit.Flush GHC.Base.String)
instance Yesod.Core.Content.ToFlushBuilder GHC.Base.String
instance Yesod.Core.Content.ToFlushBuilder (Data.Conduit.Internal.Conduit.Flush Text.Blaze.Html.Html)
instance Yesod.Core.Content.ToFlushBuilder Text.Blaze.Html.Html
instance Yesod.Core.Content.ToContent Yesod.Core.Types.Content
instance Yesod.Core.Content.ToContent Data.ByteString.Builder.Internal.Builder
instance Yesod.Core.Content.ToContent Data.ByteString.Internal.ByteString
instance Yesod.Core.Content.ToContent Data.ByteString.Lazy.Internal.ByteString
instance Yesod.Core.Content.ToContent Data.Text.Internal.Text
instance Yesod.Core.Content.ToContent Data.Text.Internal.Lazy.Text
instance Yesod.Core.Content.ToContent GHC.Base.String
instance Yesod.Core.Content.ToContent Text.Blaze.Html.Html
instance Yesod.Core.Content.ToContent ()
instance Yesod.Core.Content.ToContent (Yesod.Core.Types.ContentType, Yesod.Core.Types.Content)
instance Yesod.Core.Content.ToContent Yesod.Core.Types.TypedContent
instance Yesod.Core.Content.ToContent (Yesod.Core.Types.JSONResponse a)
instance Yesod.Core.Content.ToContent Text.Internal.Css.Css
instance Yesod.Core.Content.ToContent Text.Julius.Javascript
instance Yesod.Core.Content.ToContent a => Yesod.Core.Content.ToContent (Yesod.Core.Types.DontFullyEvaluate a)
instance Yesod.Core.Content.ToContent Data.Aeson.Types.Internal.Value
instance Yesod.Core.Content.ToContent Data.Aeson.Encoding.Internal.Encoding

module Yesod.Core.Handler

-- | <i>Deprecated: Use HandlerFor directly</i>
type HandlerT site (m :: * -> *) = HandlerFor site

-- | A generic handler monad, which can have a different subsite and master
--   site. We define a newtype for better error message.
data HandlerFor site a

-- | Get the master site application argument.
getYesod :: MonadHandler m => m (HandlerSite m)

-- | Get a specific component of the master site application argument.
--   Analogous to the <tt>gets</tt> function for operating on
--   <tt>StateT</tt>.
getsYesod :: MonadHandler m => (HandlerSite m -> a) -> m a

-- | Get the URL rendering function.
getUrlRender :: MonadHandler m => m (Route (HandlerSite m) -> Text)

-- | The URL rendering function with query-string parameters.
getUrlRenderParams :: MonadHandler m => m (Route (HandlerSite m) -> [(Text, Text)] -> Text)

-- | Get all the post parameters passed to the handler. To also get the
--   submitted files (if any), you have to use <a>runRequestBody</a>
--   instead of this function.
getPostParams :: MonadHandler m => m [(Text, Text)]

-- | Get the route requested by the user. If this is a 404 response- where
--   the user requested an invalid route- this function will return
--   <a>Nothing</a>.
getCurrentRoute :: MonadHandler m => m (Maybe (Route (HandlerSite m)))
getRequest :: MonadHandler m => m YesodRequest

-- | Get the request's <a>Request</a> value.
waiRequest :: MonadHandler m => m Request
runRequestBody :: MonadHandler m => m RequestBodyContents

-- | Stream in the raw request body without any parsing.
rawRequestBody :: MonadHandler m => ConduitT i ByteString m ()

-- | A tuple containing both the POST parameters and submitted files.
type RequestBodyContents = ([(Text, Text)], [(Text, FileInfo)])

-- | The parsed request information. This type augments the standard WAI
--   <a>Request</a> with additional information.
data YesodRequest
YesodRequest :: ![(Text, Text)] -> ![(Text, Text)] -> !Request -> ![Text] -> !Maybe Text -> !SessionMap -> ![ContentType] -> YesodRequest

-- | Same as <a>queryString</a>, but decoded to <tt>Text</tt>.
[reqGetParams] :: YesodRequest -> ![(Text, Text)]
[reqCookies] :: YesodRequest -> ![(Text, Text)]
[reqWaiRequest] :: YesodRequest -> !Request

-- | Languages which the client supports. This is an ordered list by
--   preference.
[reqLangs] :: YesodRequest -> ![Text]

-- | A random, session-specific token used to prevent CSRF attacks.
[reqToken] :: YesodRequest -> !Maybe Text

-- | Initial session sent from the client.
--   
--   Since 1.2.0
[reqSession] :: YesodRequest -> !SessionMap

-- | An ordered list of the accepted content types.
--   
--   Since 1.2.0
[reqAccept] :: YesodRequest -> ![ContentType]
data FileInfo
fileName :: FileInfo -> Text
fileContentType :: FileInfo -> Text

-- | Stream the data from the file. Since Yesod 1.2, this has been
--   generalized to work in any <tt>MonadResource</tt>.
fileSource :: MonadResource m => FileInfo -> ConduitT () ByteString m ()

-- | Extract a strict <tt>ByteString</tt> body from a <a>FileInfo</a>.
--   
--   This function will block while reading the file.
--   
--   <pre>
--   do
--       fileByteString &lt;- fileSourceByteString fileInfo
--   </pre>
fileSourceByteString :: MonadResource m => FileInfo -> m ByteString
fileMove :: FileInfo -> FilePath -> IO ()

-- | Get the list of supported languages supplied by the user.
--   
--   Languages are determined based on the following (in descending order
--   of preference):
--   
--   <ul>
--   <li>The _LANG user session variable.</li>
--   <li>The _LANG get parameter.</li>
--   <li>The _LANG cookie.</li>
--   <li>Accept-Language HTTP header.</li>
--   </ul>
--   
--   Yesod will seek the first language from the returned list matched with
--   languages supporting by your application. This language will be used
--   to render i18n templates. If a matching language is not found the
--   default language will be used.
--   
--   This is handled by parseWaiRequest (not exposed).
languages :: MonadHandler m => m [Text]

-- | Lookup for GET parameters.
lookupGetParam :: MonadHandler m => Text -> m (Maybe Text)
lookupPostParam :: (MonadResource m, MonadHandler m) => Text -> m (Maybe Text)

-- | Lookup for cookie data.
lookupCookie :: MonadHandler m => Text -> m (Maybe Text)

-- | Lookup for POSTed files.
lookupFile :: MonadHandler m => Text -> m (Maybe FileInfo)

-- | Lookup a request header.
lookupHeader :: MonadHandler m => CI ByteString -> m (Maybe ByteString)

-- | Lookup basic authentication data from <b>Authorization</b> header of
--   request. Returns user name and password
lookupBasicAuth :: MonadHandler m => m (Maybe (Text, Text))

-- | Lookup bearer authentication datafrom <b>Authorization</b> header of
--   request. Returns bearer token value
lookupBearerAuth :: MonadHandler m => m (Maybe Text)

-- | Lookup for GET parameters.
lookupGetParams :: MonadHandler m => Text -> m [Text]

-- | Lookup for POST parameters.
lookupPostParams :: (MonadResource m, MonadHandler m) => Text -> m [Text]

-- | Lookup for cookie data.
lookupCookies :: MonadHandler m => Text -> m [Text]

-- | Lookup for POSTed files.
lookupFiles :: MonadHandler m => Text -> m [FileInfo]

-- | Lookup a request header.
lookupHeaders :: MonadHandler m => CI ByteString -> m [ByteString]

-- | Provide a pure value for the response body.
--   
--   <pre>
--   respond ct = return . TypedContent ct . toContent
--   </pre>
respond :: (Monad m, ToContent a) => ContentType -> a -> m TypedContent

-- | Use a <tt>Source</tt> for the response body.
--   
--   Note that, for ease of use, the underlying monad is a
--   <tt>HandlerT</tt>. This implies that you can run any <tt>HandlerT</tt>
--   action. However, since a streaming response occurs after the response
--   headers have already been sent, some actions make no sense here. For
--   example: short-circuit responses, setting headers, changing status
--   codes, etc.
respondSource :: ContentType -> ConduitT () (Flush Builder) (HandlerFor site) () -> HandlerFor site TypedContent

-- | In a streaming response, send a single chunk of data. This function
--   works on most datatypes, such as <tt>ByteString</tt> and
--   <tt>Html</tt>.
sendChunk :: Monad m => ToFlushBuilder a => a -> ConduitT i (Flush Builder) m ()

-- | In a streaming response, send a flush command, causing all buffered
--   data to be immediately sent to the client.
sendFlush :: Monad m => ConduitT i (Flush Builder) m ()

-- | Type-specialized version of <a>sendChunk</a> for strict
--   <tt>ByteString</tt>s.
sendChunkBS :: Monad m => ByteString -> ConduitT i (Flush Builder) m ()

-- | Type-specialized version of <a>sendChunk</a> for lazy
--   <tt>ByteString</tt>s.
sendChunkLBS :: Monad m => ByteString -> ConduitT i (Flush Builder) m ()

-- | Type-specialized version of <a>sendChunk</a> for strict
--   <tt>Text</tt>s.
sendChunkText :: Monad m => Text -> ConduitT i (Flush Builder) m ()

-- | Type-specialized version of <a>sendChunk</a> for lazy <tt>Text</tt>s.
sendChunkLazyText :: Monad m => Text -> ConduitT i (Flush Builder) m ()

-- | Type-specialized version of <a>sendChunk</a> for <tt>Html</tt>s.
sendChunkHtml :: Monad m => Html -> ConduitT i (Flush Builder) m ()

-- | Some value which can be turned into a URL for redirects.
class RedirectUrl master a

-- | Converts the value to the URL and a list of query-string parameters.
toTextUrl :: (RedirectUrl master a, MonadHandler m, HandlerSite m ~ master) => a -> m Text

-- | Redirect to the given route. HTTP status code 303 for HTTP 1.1 clients
--   and 302 for HTTP 1.0 This is the appropriate choice for a
--   get-following-post technique, which should be the usual use case.
--   
--   If you want direct control of the final status code, or need a
--   different status code, please use <a>redirectWith</a>.
redirect :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => url -> m a

-- | Redirect to the given URL with the specified status code.
redirectWith :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => Status -> url -> m a

-- | Redirect to a POST resource.
--   
--   This is not technically a redirect; instead, it returns an HTML page
--   with a POST form, and some Javascript to automatically submit the
--   form. This can be useful when you need to post a plain link somewhere
--   that needs to cause changes on the server.
redirectToPost :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => url -> m a

-- | Add a fragment identifier to a route to be used when redirecting. For
--   example:
--   
--   <pre>
--   redirect (NewsfeedR :#: storyId)
--   </pre>
--   
--   @since 1.2.9.
data Fragment a b
(:#:) :: a -> b -> Fragment a b

-- | Return a 404 not found page. Also denotes no handler available.
notFound :: MonadHandler m => m a

-- | Return a 405 method not supported page.
badMethod :: MonadHandler m => m a

-- | Return a 401 status code
notAuthenticated :: MonadHandler m => m a

-- | Return a 403 permission denied page.
permissionDenied :: MonadHandler m => Text -> m a

-- | Return a 403 permission denied page.
permissionDeniedI :: (RenderMessage (HandlerSite m) msg, MonadHandler m) => msg -> m a

-- | Return a 400 invalid arguments page.
invalidArgs :: MonadHandler m => [Text] -> m a

-- | Return a 400 invalid arguments page.
invalidArgsI :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => [msg] -> m a

-- | Bypass remaining handler code and output the given file.
--   
--   For some backends, this is more efficient than reading in the file to
--   memory, since they can optimize file sending via a system call to
--   sendfile.
sendFile :: MonadHandler m => ContentType -> FilePath -> m a

-- | Same as <a>sendFile</a>, but only sends part of a file.
sendFilePart :: MonadHandler m => ContentType -> FilePath -> Integer -> Integer -> m a

-- | Bypass remaining handler code and output the given content with a 200
--   status code.
sendResponse :: (MonadHandler m, ToTypedContent c) => c -> m a

-- | Bypass remaining handler code and output the given content with the
--   given status code.
sendResponseStatus :: (MonadHandler m, ToTypedContent c) => Status -> c -> m a

-- | Bypass remaining handler code and output the given JSON with the given
--   status code.
sendStatusJSON :: (MonadHandler m, ToJSON c) => Status -> c -> m a

-- | Send a 201 <a>Created</a> response with the given route as the
--   Location response header.
sendResponseCreated :: MonadHandler m => Route (HandlerSite m) -> m a

-- | Bypass remaining handler code and output no content with a 204 status
--   code.
sendResponseNoContent :: MonadHandler m => m a

-- | Send a <a>Response</a>. Please note: this function is rarely
--   necessary, and will <i>disregard</i> any changes to response headers
--   and session that you have already specified. This function
--   short-circuits. It should be considered only for very specific needs.
--   If you are not sure if you need it, you don't.
sendWaiResponse :: MonadHandler m => Response -> m b

-- | Switch over to handling the current request with a WAI
--   <tt>Application</tt>.
sendWaiApplication :: MonadHandler m => Application -> m b

-- | Send a raw response. This is used for cases such as WebSockets.
--   Requires WAI 2.1 or later, and a web server which supports raw
--   responses (e.g., Warp).
sendRawResponse :: (MonadHandler m, MonadUnliftIO m) => (ConduitT () ByteString IO () -> ConduitT ByteString Void IO () -> m ()) -> m a

-- | Send a raw response without conduit. This is used for cases such as
--   WebSockets. Requires WAI 3.0 or later, and a web server which supports
--   raw responses (e.g., Warp).
sendRawResponseNoConduit :: (MonadHandler m, MonadUnliftIO m) => (IO ByteString -> (ByteString -> IO ()) -> m ()) -> m a

-- | Send a 304 not modified response immediately. This is a
--   short-circuiting action.
notModified :: MonadHandler m => m a

-- | Select a representation to send to the client based on the
--   representations provided inside this do-block. Should be used together
--   with <a>provideRep</a>.
selectRep :: MonadHandler m => Writer (Endo [ProvidedRep m]) () -> m TypedContent

-- | Provide a single representation to be used, based on the request of
--   the client. Should be used together with <a>selectRep</a>.
provideRep :: (Monad m, HasContentType a) => m a -> Writer (Endo [ProvidedRep m]) ()

-- | Same as <a>provideRep</a>, but instead of determining the content type
--   from the type of the value itself, you provide the content type
--   separately. This can be a convenience instead of creating newtype
--   wrappers for uncommonly used content types.
--   
--   <pre>
--   provideRepType "application/x-special-format" "This is the content"
--   </pre>
provideRepType :: (Monad m, ToContent a) => ContentType -> m a -> Writer (Endo [ProvidedRep m]) ()

-- | Internal representation of a single provided representation.
data ProvidedRep m

-- | Set the cookie on the client.
setCookie :: MonadHandler m => SetCookie -> m ()

-- | Helper function for setCookieExpires value
getExpires :: MonadIO m => Int -> m UTCTime

-- | Unset the cookie on the client.
--   
--   Note: although the value used for key and path is <a>Text</a>, you
--   should only use ASCII values to be HTTP compliant.
deleteCookie :: MonadHandler m => Text -> Text -> m ()

-- | Set an arbitrary response header.
--   
--   Note that, while the data type used here is <a>Text</a>, you must
--   provide only ASCII value to be HTTP compliant.
addHeader :: MonadHandler m => Text -> Text -> m ()

-- | Deprecated synonym for addHeader.

-- | <i>Deprecated: Please use addHeader instead</i>
setHeader :: MonadHandler m => Text -> Text -> m ()

-- | Replace an existing header with a new value or add a new header if not
--   present.
--   
--   Note that, while the data type used here is <a>Text</a>, you must
--   provide only ASCII value to be HTTP compliant.
replaceOrAddHeader :: MonadHandler m => Text -> Text -> m ()

-- | Set the language in the user session. Will show up in <a>languages</a>
--   on the next request.
setLanguage :: MonadHandler m => Text -> m ()

-- | Set attachment file name.
--   
--   Allows Unicode characters by encoding to UTF-8. Some modurn browser
--   parse UTF-8 characters with out encoding setting. But, for example IE9
--   can't parse UTF-8 characters. This function use <a>RFC 6266</a>(<a>RFC
--   5987</a>)
addContentDispositionFileName :: MonadHandler m => Text -> m ()

-- | Set the Cache-Control header to indicate this response should be
--   cached for the given number of seconds.
cacheSeconds :: MonadHandler m => Int -> m ()

-- | Set the Expires header to some date in 2037. In other words, this
--   content is never (realistically) expired.
neverExpires :: MonadHandler m => m ()

-- | Set an Expires header in the past, meaning this content should not be
--   cached.
alreadyExpired :: MonadHandler m => m ()

-- | Set an Expires header to the given date.
expiresAt :: MonadHandler m => UTCTime -> m ()

-- | Check the if-none-match header and, if it matches the given value,
--   return a 304 not modified response. Otherwise, set the etag header to
--   the given value.
--   
--   Note that it is the responsibility of the caller to ensure that the
--   provided value is a valid etag value, no sanity checking is performed
--   by this function.
setEtag :: MonadHandler m => Text -> m ()

-- | Check the if-none-match header and, if it matches the given value,
--   return a 304 not modified response. Otherwise, set the etag header to
--   the given value.
--   
--   A weak etag is only expected to be semantically identical to the prior
--   content, but doesn't have to be byte-for-byte identical. Therefore it
--   can be useful for dynamically generated content that may be difficult
--   to perform bytewise hashing upon.
--   
--   Note that it is the responsibility of the caller to ensure that the
--   provided value is a valid etag value, no sanity checking is performed
--   by this function.
setWeakEtag :: MonadHandler m => Text -> m ()
type SessionMap = Map Text ByteString

-- | Lookup for session data.
lookupSession :: MonadHandler m => Text -> m (Maybe Text)

-- | Lookup for session data in binary format.
lookupSessionBS :: MonadHandler m => Text -> m (Maybe ByteString)

-- | Get all session variables.
getSession :: MonadHandler m => m SessionMap

-- | Set a variable in the user's session.
--   
--   The session is handled by the clientsession package: it sets an
--   encrypted and hashed cookie on the client. This ensures that all data
--   is secure and not tampered with.
setSession :: MonadHandler m => Text -> Text -> m ()

-- | Same as <a>setSession</a>, but uses binary data for the value.
setSessionBS :: MonadHandler m => Text -> ByteString -> m ()

-- | Unsets a session variable. See <a>setSession</a>.
deleteSession :: MonadHandler m => Text -> m ()

-- | Clear all session variables.
--   
--   @since: 1.0.1
clearSession :: MonadHandler m => m ()

-- | Sets the ultimate destination variable to the given route.
--   
--   An ultimate destination is stored in the user session and can be
--   loaded later by <a>redirectUltDest</a>.
setUltDest :: (MonadHandler m, RedirectUrl (HandlerSite m) url) => url -> m ()

-- | Same as <a>setUltDest</a>, but uses the current page.
--   
--   If this is a 404 handler, there is no current page, and then this call
--   does nothing.
setUltDestCurrent :: MonadHandler m => m ()

-- | Sets the ultimate destination to the referer request header, if
--   present.
--   
--   This function will not overwrite an existing ultdest.
setUltDestReferer :: MonadHandler m => m ()

-- | Redirect to the ultimate destination in the user's session. Clear the
--   value from the session.
--   
--   The ultimate destination is set with <a>setUltDest</a>.
--   
--   This function uses <a>redirect</a>, and thus will perform a temporary
--   redirect to a GET request.
redirectUltDest :: (RedirectUrl (HandlerSite m) url, MonadHandler m) => url -> m a

-- | Remove a previously set ultimate destination. See <a>setUltDest</a>.
clearUltDest :: MonadHandler m => m ()

-- | Adds a status and message in the user's session.
--   
--   See <a>getMessages</a>.
addMessage :: MonadHandler m => Text -> Html -> m ()

-- | Adds a message in the user's session but uses RenderMessage to allow
--   for i18n
--   
--   See <a>getMessages</a>.
addMessageI :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => Text -> msg -> m ()

-- | Gets all messages in the user's session, and then clears the variable.
--   
--   See <a>addMessage</a>.
getMessages :: MonadHandler m => m [(Text, Html)]

-- | Calls <a>addMessage</a> with an empty status
setMessage :: MonadHandler m => Html -> m ()

-- | Calls <a>addMessageI</a> with an empty status
setMessageI :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => msg -> m ()

-- | Gets just the last message in the user's session, discards the rest
--   and the status
getMessage :: MonadHandler m => m (Maybe Html)

-- | A handler monad for subsite
data SubHandlerFor sub master a
getSubYesod :: MonadHandler m => m (SubHandlerSite m)
getRouteToParent :: MonadHandler m => m (Route (SubHandlerSite m) -> Route (HandlerSite m))
getSubCurrentRoute :: MonadHandler m => m (Maybe (Route (SubHandlerSite m)))

-- | Wraps the <a>Content</a> generated by <tt>hamletToContent</tt> in a
--   <a>RepHtml</a>.

-- | <i>Deprecated: Use withUrlRenderer instead</i>
hamletToRepHtml :: MonadHandler m => HtmlUrl (Route (HandlerSite m)) -> m Html

-- | Deprecated synonym for <a>withUrlRenderer</a>.

-- | <i>Deprecated: Use withUrlRenderer instead</i>
giveUrlRenderer :: MonadHandler m => ((Route (HandlerSite m) -> [(Text, Text)] -> Text) -> output) -> m output

-- | Provide a URL rendering function to the given function and return the
--   result. Useful for processing Shakespearean templates.
withUrlRenderer :: MonadHandler m => ((Route (HandlerSite m) -> [(Text, Text)] -> Text) -> output) -> m output

-- | Get a unique identifier.
newIdent :: MonadHandler m => m Text

-- | Returns a function that runs <a>HandlerT</a> actions inside
--   <tt>IO</tt>.
--   
--   Sometimes you want to run an inner <a>HandlerT</a> action outside the
--   control flow of an HTTP request (on the outer <a>HandlerT</a> action).
--   For example, you may want to spawn a new thread:
--   
--   <pre>
--   getFooR :: Handler RepHtml
--   getFooR = do
--     runInnerHandler &lt;- handlerToIO
--     liftIO $ forkIO $ runInnerHandler $ do
--       <i>Code here runs inside GHandler but on a new thread.</i>
--       <i>This is the inner GHandler.</i>
--       ...
--     <i>Code here runs inside the request's control flow.</i>
--     <i>This is the outer GHandler.</i>
--     ...
--   </pre>
--   
--   Another use case for this function is creating a stream of server-sent
--   events using <tt>GHandler</tt> actions (see
--   <tt>yesod-eventsource</tt>).
--   
--   Most of the environment from the outer <tt>GHandler</tt> is preserved
--   on the inner <tt>GHandler</tt>, however:
--   
--   <ul>
--   <li>The request body is cleared (otherwise it would be very difficult
--   to prevent huge memory leaks).</li>
--   <li>The cache is cleared (see <tt>CacheKey</tt>).</li>
--   </ul>
--   
--   Changes to the response made inside the inner <tt>GHandler</tt> are
--   ignored (e.g., session variables, cookies, response headers). This
--   allows the inner <tt>GHandler</tt> to outlive the outer
--   <tt>GHandler</tt> (e.g., on the <tt>forkIO</tt> example above, a
--   response may be sent to the client without killing the new thread).
handlerToIO :: MonadIO m => HandlerFor site (HandlerFor site a -> m a)

-- | forkIO for a Handler (run an action in the background)
--   
--   Uses <a>handlerToIO</a>, liftResourceT, and resourceForkIO for
--   correctness and efficiency
forkHandler :: (SomeException -> HandlerFor site ()) -> HandlerFor site () -> HandlerFor site ()
getMessageRender :: (MonadHandler m, RenderMessage (HandlerSite m) message) => m (message -> Text)

-- | Use a per-request cache to avoid performing the same action multiple
--   times. Values are stored by their type, the result of typeOf from
--   Typeable. Therefore, you should use different newtype wrappers at each
--   cache site.
--   
--   For example, yesod-auth uses an un-exported newtype, CachedMaybeAuth
--   and exports functions that utilize it such as maybeAuth. This means
--   that another module can create its own newtype wrapper to cache the
--   same type from a different action without any cache conflicts.
--   
--   See the original announcement:
--   <a>http://www.yesodweb.com/blog/2013/03/yesod-1-2-cleaner-internals</a>
cached :: (MonadHandler m, Typeable a) => m a -> m a

-- | Retrieves a value from the cache used by <a>cached</a>.
cacheGet :: (MonadHandler m, Typeable a) => m (Maybe a)

-- | Sets a value in the cache used by <a>cached</a>.
cacheSet :: (MonadHandler m, Typeable a) => a -> m ()

-- | a per-request cache. just like <a>cached</a>. <a>cached</a> can only
--   cache a single value per type. <a>cachedBy</a> stores multiple values
--   per type by usage of a ByteString key
--   
--   <a>cached</a> is ideal to cache an action that has only one value of a
--   type, such as the session's current user <a>cachedBy</a> is required
--   if the action has parameters and can return multiple values per type.
--   You can turn those parameters into a ByteString cache key. For
--   example, caching a lookup of a Link by a token where multiple token
--   lookups might be performed.
cachedBy :: (MonadHandler m, Typeable a) => ByteString -> m a -> m a

-- | Retrieves a value from the cache used by <a>cachedBy</a>.
cacheByGet :: (MonadHandler m, Typeable a) => ByteString -> m (Maybe a)

-- | Sets a value in the cache used by <a>cachedBy</a>.
cacheBySet :: (MonadHandler m, Typeable a) => ByteString -> a -> m ()

-- | Sets a cookie with a CSRF token, using <a>defaultCsrfCookieName</a>
--   for the cookie name.
--   
--   The cookie's path is set to <tt>/</tt>, making it valid for your whole
--   website.
setCsrfCookie :: MonadHandler m => m ()

-- | Takes a <a>SetCookie</a> and overrides its value with a CSRF token,
--   then sets the cookie.
--   
--   Make sure to set the <a>setCookiePath</a> to the root path of your
--   application, otherwise you'll generate a new CSRF token for every path
--   of your app. If your app is run from from e.g. www.example.com/app1,
--   use <tt>app1</tt>. The vast majority of sites will just use
--   <tt>/</tt>.
setCsrfCookieWithCookie :: MonadHandler m => SetCookie -> m ()

-- | The default cookie name for the CSRF token ("XSRF-TOKEN").
defaultCsrfCookieName :: ByteString

-- | Takes a header name to lookup a CSRF token. If the value doesn't match
--   the token stored in the session, this function throws a
--   <a>PermissionDenied</a> error.
checkCsrfHeaderNamed :: MonadHandler m => CI ByteString -> m ()

-- | Takes a header name to lookup a CSRF token, and returns whether the
--   value matches the token stored in the session.
hasValidCsrfHeaderNamed :: MonadHandler m => CI ByteString -> m Bool

-- | The default header name for the CSRF token ("X-XSRF-TOKEN").
defaultCsrfHeaderName :: CI ByteString

-- | Takes a POST parameter name to lookup a CSRF token, and returns
--   whether the value matches the token stored in the session.
hasValidCsrfParamNamed :: MonadHandler m => Text -> m Bool

-- | Takes a POST parameter name to lookup a CSRF token. If the value
--   doesn't match the token stored in the session, this function throws a
--   <a>PermissionDenied</a> error.
checkCsrfParamNamed :: MonadHandler m => Text -> m ()

-- | The default parameter name for the CSRF token ("_token")
defaultCsrfParamName :: Text

-- | Checks that a valid CSRF token is present in either the request
--   headers or POST parameters. If the value doesn't match the token
--   stored in the session, this function throws a <a>PermissionDenied</a>
--   error.
checkCsrfHeaderOrParam :: (MonadHandler m, MonadLogger m) => CI ByteString -> Text -> m ()
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Yesod.Core.Handler.Fragment a b)
instance GHC.Classes.Eq Yesod.Core.Handler.Etag
instance GHC.Show.Show Yesod.Core.Handler.Etag
instance (Yesod.Core.Handler.RedirectUrl master a, Web.PathPieces.PathPiece b) => Yesod.Core.Handler.RedirectUrl master (Yesod.Core.Handler.Fragment a b)
instance Yesod.Core.Handler.RedirectUrl master Data.Text.Internal.Text
instance Yesod.Core.Handler.RedirectUrl master GHC.Base.String
instance Yesod.Core.Handler.RedirectUrl master (Yesod.Routes.Class.Route master)
instance (key Data.Type.Equality.~ Data.Text.Internal.Text, val Data.Type.Equality.~ Data.Text.Internal.Text) => Yesod.Core.Handler.RedirectUrl master (Yesod.Routes.Class.Route master, [(key, val)])
instance (key Data.Type.Equality.~ Data.Text.Internal.Text, val Data.Type.Equality.~ Data.Text.Internal.Text) => Yesod.Core.Handler.RedirectUrl master (Yesod.Routes.Class.Route master, Data.Map.Internal.Map key val)


-- | Widgets combine HTML with JS and CSS dependencies with a unique
--   identifier generator, allowing you to create truly modular HTML
--   components.
module Yesod.Core.Widget

-- | <i>Deprecated: Use WidgetFor directly</i>
type WidgetT site (m :: * -> *) = WidgetFor site

-- | A generic widget, allowing specification of both the subsite and
--   master site datatypes. While this is simply a <tt>WriterT</tt>, we
--   define a newtype for better error messages.
data WidgetFor site a

-- | Content for a web page. By providing this datatype, we can easily
--   create generic site templates, which would have the type signature:
--   
--   <pre>
--   PageContent url -&gt; HtmlUrl url
--   </pre>
data PageContent url
PageContent :: !Html -> !HtmlUrl url -> !HtmlUrl url -> PageContent url
[pageTitle] :: PageContent url -> !Html
[pageHead] :: PageContent url -> !HtmlUrl url
[pageBody] :: PageContent url -> !HtmlUrl url
whamlet :: QuasiQuoter
whamletFile :: FilePath -> Q Exp

-- | Wraps the <a>Content</a> generated by <tt>hamletToContent</tt> in a
--   <a>RepHtml</a>.

-- | <i>Deprecated: Please use ihamletToHtml instead</i>
ihamletToRepHtml :: (MonadHandler m, RenderMessage (HandlerSite m) message) => HtmlUrlI18n message (Route (HandlerSite m)) -> m Html

-- | Wraps the <a>Content</a> generated by <tt>hamletToContent</tt> in a
--   <a>RepHtml</a>.
--   
--   Since 1.2.1
ihamletToHtml :: (MonadHandler m, RenderMessage (HandlerSite m) message) => HtmlUrlI18n message (Route (HandlerSite m)) -> m Html
class ToWidget site a
toWidget :: (ToWidget site a, MonadWidget m, HandlerSite m ~ site) => a -> m ()
class ToWidgetHead site a
toWidgetHead :: (ToWidgetHead site a, MonadWidget m, HandlerSite m ~ site) => a -> m ()
class ToWidgetBody site a
toWidgetBody :: (ToWidgetBody site a, MonadWidget m, HandlerSite m ~ site) => a -> m ()

-- | Allows adding some CSS to the page with a specific media type.
--   
--   Since 1.2
class ToWidgetMedia site a

-- | Add the given content to the page, but only for the given media type.
--   
--   Since 1.2
toWidgetMedia :: (ToWidgetMedia site a, MonadWidget m, HandlerSite m ~ site) => Text -> a -> m ()

-- | Set the page title. Calling <a>setTitle</a> multiple times overrides
--   previously set values.
setTitle :: MonadWidget m => Html -> m ()

-- | Set the page title. Calling <a>setTitle</a> multiple times overrides
--   previously set values.
setTitleI :: (MonadWidget m, RenderMessage (HandlerSite m) msg) => msg -> m ()

-- | Link to the specified local stylesheet.
addStylesheet :: MonadWidget m => Route (HandlerSite m) -> m ()

-- | Link to the specified local stylesheet.
addStylesheetAttrs :: MonadWidget m => Route (HandlerSite m) -> [(Text, Text)] -> m ()

-- | Link to the specified remote stylesheet.
addStylesheetRemote :: MonadWidget m => Text -> m ()

-- | Link to the specified remote stylesheet.
addStylesheetRemoteAttrs :: MonadWidget m => Text -> [(Text, Text)] -> m ()
addStylesheetEither :: MonadWidget m => Either (Route (HandlerSite m)) Text -> m ()

-- | Newtype wrapper allowing injection of arbitrary content into CSS.
--   
--   Usage:
--   
--   <pre>
--   toWidget $ CssBuilder "p { color: red }"
--   </pre>
--   
--   Since: 1.1.3
newtype CssBuilder
CssBuilder :: Builder -> CssBuilder
[unCssBuilder] :: CssBuilder -> Builder

-- | Link to the specified local script.
addScript :: MonadWidget m => Route (HandlerSite m) -> m ()

-- | Link to the specified local script.
addScriptAttrs :: MonadWidget m => Route (HandlerSite m) -> [(Text, Text)] -> m ()

-- | Link to the specified remote script.
addScriptRemote :: MonadWidget m => Text -> m ()

-- | Link to the specified remote script.
addScriptRemoteAttrs :: MonadWidget m => Text -> [(Text, Text)] -> m ()
addScriptEither :: MonadWidget m => Either (Route (HandlerSite m)) Text -> m ()
handlerToWidget :: HandlerFor site a -> WidgetFor site a
whamletFileWithSettings :: HamletSettings -> FilePath -> Q Exp
asWidgetT :: WidgetT site m () -> WidgetT site m ()
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetHead site (render -> Text.Blaze.Html.Html)
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetHead site (render -> Text.Internal.Css.Css)
instance Yesod.Core.Widget.ToWidgetHead site Text.Internal.Css.Css
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetHead site (render -> Yesod.Core.Types.CssBuilder)
instance Yesod.Core.Widget.ToWidgetHead site Yesod.Core.Types.CssBuilder
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetHead site (render -> Text.Julius.Javascript)
instance Yesod.Core.Widget.ToWidgetHead site Text.Julius.Javascript
instance Yesod.Core.Widget.ToWidgetHead site Text.Blaze.Html.Html
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetBody site (render -> Text.Blaze.Html.Html)
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetBody site (render -> Text.Julius.Javascript)
instance Yesod.Core.Widget.ToWidgetBody site Text.Julius.Javascript
instance Yesod.Core.Widget.ToWidgetBody site Text.Blaze.Html.Html
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetMedia site (render -> Text.Internal.Css.Css)
instance Yesod.Core.Widget.ToWidgetMedia site Text.Internal.Css.Css
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidgetMedia site (render -> Yesod.Core.Types.CssBuilder)
instance Yesod.Core.Widget.ToWidgetMedia site Yesod.Core.Types.CssBuilder
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidget site (render -> Text.Blaze.Html.Html)
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidget site (render -> Text.Internal.Css.Css)
instance Yesod.Core.Widget.ToWidget site Text.Internal.Css.Css
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidget site (render -> Yesod.Core.Types.CssBuilder)
instance Yesod.Core.Widget.ToWidget site Yesod.Core.Types.CssBuilder
instance (render Data.Type.Equality.~ Yesod.Core.Types.RY site) => Yesod.Core.Widget.ToWidget site (render -> Text.Julius.Javascript)
instance Yesod.Core.Widget.ToWidget site Text.Julius.Javascript
instance (site' Data.Type.Equality.~ site, a Data.Type.Equality.~ ()) => Yesod.Core.Widget.ToWidget site' (Yesod.Core.Types.WidgetFor site a)
instance Yesod.Core.Widget.ToWidget site Text.Blaze.Html.Html
instance Yesod.Core.Widget.ToWidget site Data.Text.Internal.Text
instance Yesod.Core.Widget.ToWidget site Data.Text.Internal.Lazy.Text
instance Yesod.Core.Widget.ToWidget site Data.Text.Internal.Builder.Builder

module Yesod.Core.Json

-- | Provide both an HTML and JSON representation for a piece of data,
--   using the default layout for the HTML output (<a>defaultLayout</a>).
defaultLayoutJson :: (Yesod site, ToJSON a) => WidgetFor site () -> HandlerFor site a -> HandlerFor site TypedContent

-- | Wraps a data type in a <tt>RepJson</tt>. The data type must support
--   conversion to JSON via <a>ToJSON</a>.

-- | <i>Deprecated: Use returnJson instead</i>
jsonToRepJson :: (Monad m, ToJSON a) => a -> m Value

-- | Convert a value to a JSON representation via aeson's <a>toJSON</a>
--   function.
returnJson :: (Monad m, ToJSON a) => a -> m Value

-- | Convert a value to a JSON representation via aeson's <a>toEncoding</a>
--   function.
returnJsonEncoding :: (Monad m, ToJSON a) => a -> m Encoding

-- | Provide a JSON representation for usage with <tt>selectReps</tt>,
--   using aeson's <a>toJSON</a> (aeson &gt;= 0.11: <a>toEncoding</a>)
--   function to perform the conversion.
provideJson :: (Monad m, ToJSON a) => a -> Writer (Endo [ProvidedRep m]) ()

-- | Parse the request body to a data type as a JSON value. The data type
--   must support conversion from JSON via <a>FromJSON</a>. If you want the
--   raw JSON value, just ask for a <tt><a>Result</a> <a>Value</a></tt>.
--   
--   The MIME type must indicate JSON content. Requiring a JSON
--   content-type helps secure your site against CSRF attacks (browsers
--   will perform POST requests for form and text/plain content-types
--   without doing a CORS check, and those content-types can easily contain
--   valid JSON).
--   
--   Note that this function will consume the request body. As such,
--   calling it twice will result in a parse error on the second call,
--   since the request body will no longer be available.
parseCheckJsonBody :: (MonadHandler m, FromJSON a) => m (Result a)

-- | Same as <a>parseCheckJsonBody</a>, but does not check that the mime
--   type indicates JSON content.
--   
--   Note: This function is vulnerable to CSRF attacks.
parseInsecureJsonBody :: (MonadHandler m, FromJSON a) => m (Result a)

-- | Same as <a>parseCheckJsonBody</a>, but return an invalid args response
--   on a parse error.
requireCheckJsonBody :: (MonadHandler m, FromJSON a) => m a

-- | Same as <a>parseInsecureJsonBody</a>, but return an invalid args
--   response on a parse error.
requireInsecureJsonBody :: (MonadHandler m, FromJSON a) => m a

-- | Same as <a>parseInsecureJsonBody</a>

-- | <i>Deprecated: Use parseCheckJsonBody or parseInsecureJsonBody
--   instead</i>
parseJsonBody :: (MonadHandler m, FromJSON a) => m (Result a)

-- | Same as <a>parseInsecureJsonBody</a>, but return an invalid args
--   response on a parse error.

-- | <i>Deprecated: Use requireCheckJsonBody or requireInsecureJsonBody
--   instead</i>
parseJsonBody_ :: (MonadHandler m, FromJSON a) => m a

-- | Same as <a>parseInsecureJsonBody</a>, but return an invalid args
--   response on a parse error.

-- | <i>Deprecated: Use requireCheckJsonBody or requireInsecureJsonBody
--   instead</i>
requireJsonBody :: (MonadHandler m, FromJSON a) => m a

-- | A JSON value represented as a Haskell value.
data Value
Object :: !Object -> Value
Array :: !Array -> Value
String :: !Text -> Value
Number :: !Scientific -> Value
Bool :: !Bool -> Value
Null :: Value

-- | A type that can be converted to JSON.
--   
--   Instances in general <i>must</i> specify <a>toJSON</a> and
--   <i>should</i> (but don't need to) specify <a>toEncoding</a>.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>ToJSON</a> Coord where
--     <a>toJSON</a> (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     <a>toEncoding</a> (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <a>&lt;&gt;</a> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance. If you
--   require nothing other than <a>defaultOptions</a>, it is sufficient to
--   write (and this is the only alternative where the default
--   <a>toJSON</a> implementation is sufficient):
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   If on the other hand you wish to customize the generic decoding, you
--   have to implement both methods:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toJSON</a>     = <a>genericToJSON</a> customOptions
--       <a>toEncoding</a> = <a>genericToEncoding</a> customOptions
--   </pre>
--   
--   Previous versions of this library only had the <a>toJSON</a> method.
--   Adding <a>toEncoding</a> had two reasons:
--   
--   <ol>
--   <li>toEncoding is more efficient for the common case that the output
--   of <a>toJSON</a> is directly serialized to a <tt>ByteString</tt>.
--   Further, expressing either method in terms of the other would be
--   non-optimal.</li>
--   <li>The choice of defaults allows a smooth transition for existing
--   users: Existing instances that do not define <a>toEncoding</a> still
--   compile and have the correct semantics. This is ensured by making the
--   default implementation of <a>toEncoding</a> use <a>toJSON</a>. This
--   produces correct results, but since it performs an intermediate
--   conversion to a <a>Value</a>, it will be less efficient than directly
--   emitting an <a>Encoding</a>. (this also means that specifying nothing
--   more than <tt>instance ToJSON Coord</tt> would be sufficient as a
--   generically decoding instance, but there probably exists no good
--   reason to not specify <a>toEncoding</a> in new instances.)</li>
--   </ol>
class ToJSON a

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: ToJSON a => a -> Value

-- | Encode a Haskell value as JSON.
--   
--   The default implementation of this method creates an intermediate
--   <a>Value</a> using <a>toJSON</a>. This provides source-level
--   compatibility for people upgrading from older versions of this
--   library, but obviously offers no performance advantage.
--   
--   To benefit from direct encoding, you <i>must</i> provide an
--   implementation for this method. The easiest way to do so is by having
--   your types implement <a>Generic</a> using the <tt>DeriveGeneric</tt>
--   extension, and then have GHC generate a method body as follows.
--   
--   <pre>
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><a>fail</a> yields a custom error message: it is the recommended
--   way of reporting a failure;</li>
--   <li><a>empty</a> (or <a>mzero</a>) is uninformative: use it when the
--   error is meant to be caught by some <tt>(<a>&lt;|&gt;</a>)</tt>;</li>
--   <li><a>typeMismatch</a> can be used to report a failure when the
--   encountered value is not of the expected JSON type; <a>unexpected</a>
--   is an appropriate alternative when more than one type may be expected,
--   or to keep the expected type implicit.</li>
--   </ul>
--   
--   <a>prependFailure</a> (or <a>modifyFailure</a>) add more information
--   to a parser's error messages.
--   
--   An example type and instance using <a>typeMismatch</a> and
--   <a>prependFailure</a>:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> (<a>Object</a> v) = Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   
--       -- We do not expect a non-<a>Object</a> value here.
--       -- We could use <a>empty</a> to fail, but <a>typeMismatch</a>
--       -- gives a much more informative error message.
--       <a>parseJSON</a> invalid    =
--           <a>prependFailure</a> "parsing Coord failed, "
--               (<a>typeMismatch</a> "Object" invalid)
--   </pre>
--   
--   For this common case of only being concerned with a single type of
--   JSON value, the functions <a>withObject</a>, <a>withScientific</a>,
--   etc. are provided. Their use is to be preferred when possible, since
--   they are more terse. Using <a>withObject</a>, we can rewrite the above
--   instance (assuming the same language extension and data type) as:
--   
--   <pre>
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>withObject</a> "Coord" $ \v -&gt; Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>FromJSON</a> Coord
--   </pre>
--   
--   The default implementation will be equivalent to <tt>parseJSON =
--   <a>genericParseJSON</a> <a>defaultOptions</a></tt>; if you need
--   different options, you can customize the generic decoding by defining:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>genericParseJSON</a> customOptions
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]

-- | Convert a list of values to an <a>Value</a>.
array :: ToJSON a => [a] -> Value

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value
(.=) :: (KeyValue kv, ToJSON v) => Text -> v -> kv
infixr 8 .=

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use <a>.:?</a> instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | jsonOrRedirect simplifies the scenario where a POST handler sends a
--   different response based on Accept headers:
--   
--   <ol>
--   <li>200 with JSON data if the client prefers <tt>application/json</tt>
--   (e.g. AJAX, see <tt>acceptsJSON</tt>).</li>
--   <li>3xx otherwise, following the PRG pattern.</li>
--   </ol>
jsonOrRedirect :: (MonadHandler m, ToJSON a) => Route (HandlerSite m) -> a -> m Value

-- | jsonEncodingOrRedirect simplifies the scenario where a POST handler
--   sends a different response based on Accept headers:
--   
--   <ol>
--   <li>200 with JSON data if the client prefers <tt>application/json</tt>
--   (e.g. AJAX, see <tt>acceptsJSON</tt>).</li>
--   <li>3xx otherwise, following the PRG pattern. @since 1.4.21</li>
--   </ol>
jsonEncodingOrRedirect :: (MonadHandler m, ToJSON a) => Route (HandlerSite m) -> a -> m Encoding

-- | Returns <tt>True</tt> if the client prefers <tt>application/json</tt>
--   as indicated by the <tt>Accept</tt> HTTP header.
acceptsJson :: MonadHandler m => m Bool


-- | This is designed to be used as
--   
--   <pre>
--   import qualified Yesod.Core.Unsafe as Unsafe
--   </pre>
--   
--   This serves as a reminder that the functions are unsafe to use in many
--   situations.
module Yesod.Core.Unsafe

-- | Run a <tt>HandlerT</tt> completely outside of Yesod. This function
--   comes with many caveats and you shouldn't use it unless you fully
--   understand what it's doing and how it works.
--   
--   As of now, there's only one reason to use this function at all: in
--   order to run unit tests of functions inside <tt>HandlerT</tt> but that
--   aren't easily testable with a full HTTP request. Even so, it's better
--   to use <tt>wai-test</tt> or <tt>yesod-test</tt> instead of using this
--   function.
--   
--   This function will create a fake HTTP request (both <tt>wai</tt>'s
--   <a>Request</a> and <tt>yesod</tt>'s <a>Request</a>) and feed it to the
--   <tt>HandlerT</tt>. The only useful information the <tt>HandlerT</tt>
--   may get from the request is the session map, which you must supply as
--   argument to <tt>runFakeHandler</tt>. All other fields contain fake
--   information, which means that they can be accessed but won't have any
--   useful information. The response of the <tt>HandlerT</tt> is
--   completely ignored, including changes to the session, cookies or
--   headers. We only return you the <tt>HandlerT</tt>'s return value.
runFakeHandler :: (Yesod site, MonadIO m) => SessionMap -> (site -> Logger) -> site -> HandlerFor site a -> m (Either ErrorResponse a)

-- | designed to be used as
--   
--   <pre>
--   unsafeHandler = Unsafe.fakeHandlerGetLogger appLogger
--   </pre>
fakeHandlerGetLogger :: (Yesod site, MonadIO m) => (site -> Logger) -> site -> HandlerFor site a -> m a


-- | Warning! This module is considered internal and may have breaking
--   changes
module Yesod.Routes.TH.Types
data Resource typ
Resource :: String -> [Piece typ] -> Dispatch typ -> [String] -> CheckOverlap -> Resource typ
[resourceName] :: Resource typ -> String
[resourcePieces] :: Resource typ -> [Piece typ]
[resourceDispatch] :: Resource typ -> Dispatch typ
[resourceAttrs] :: Resource typ -> [String]
[resourceCheck] :: Resource typ -> CheckOverlap
data ResourceTree typ
ResourceLeaf :: Resource typ -> ResourceTree typ
ResourceParent :: String -> CheckOverlap -> [Piece typ] -> [ResourceTree typ] -> ResourceTree typ
data Piece typ
Static :: String -> Piece typ
Dynamic :: typ -> Piece typ
data Dispatch typ
Methods :: Maybe typ -> [String] -> Dispatch typ

-- | type of the multi piece at the end
[methodsMulti] :: Dispatch typ -> Maybe typ

-- | supported request methods
[methodsMethods] :: Dispatch typ -> [String]
Subsite :: typ -> String -> Dispatch typ
[subsiteType] :: Dispatch typ -> typ
[subsiteFunc] :: Dispatch typ -> String
type CheckOverlap = Bool
data FlatResource a
FlatResource :: [(String, [Piece a])] -> String -> [Piece a] -> Dispatch a -> Bool -> FlatResource a
[frParentPieces] :: FlatResource a -> [(String, [Piece a])]
[frName] :: FlatResource a -> String
[frPieces] :: FlatResource a -> [Piece a]
[frDispatch] :: FlatResource a -> Dispatch a
[frCheck] :: FlatResource a -> Bool
resourceMulti :: Resource typ -> Maybe typ
resourceTreePieces :: ResourceTree typ -> [Piece typ]
resourceTreeName :: ResourceTree typ -> String
flatten :: [ResourceTree a] -> [FlatResource a]
instance GHC.Show.Show a => GHC.Show.Show (Yesod.Routes.TH.Types.FlatResource a)
instance GHC.Base.Functor Yesod.Routes.TH.Types.ResourceTree
instance GHC.Show.Show typ => GHC.Show.Show (Yesod.Routes.TH.Types.ResourceTree typ)
instance GHC.Base.Functor Yesod.Routes.TH.Types.Resource
instance GHC.Show.Show typ => GHC.Show.Show (Yesod.Routes.TH.Types.Resource typ)
instance GHC.Show.Show typ => GHC.Show.Show (Yesod.Routes.TH.Types.Dispatch typ)
instance GHC.Show.Show typ => GHC.Show.Show (Yesod.Routes.TH.Types.Piece typ)
instance Language.Haskell.TH.Syntax.Lift t => Language.Haskell.TH.Syntax.Lift (Yesod.Routes.TH.Types.ResourceTree t)
instance Language.Haskell.TH.Syntax.Lift t => Language.Haskell.TH.Syntax.Lift (Yesod.Routes.TH.Types.Resource t)
instance GHC.Base.Functor Yesod.Routes.TH.Types.Dispatch
instance Language.Haskell.TH.Syntax.Lift t => Language.Haskell.TH.Syntax.Lift (Yesod.Routes.TH.Types.Dispatch t)
instance GHC.Base.Functor Yesod.Routes.TH.Types.Piece
instance Language.Haskell.TH.Syntax.Lift t => Language.Haskell.TH.Syntax.Lift (Yesod.Routes.TH.Types.Piece t)


-- | Exposed mostly for testing. These functions provide an unstable API
--   and should not be relied upon.
module Yesod.Core.Internal
parseWaiRequest :: Request -> SessionMap -> Bool -> Maybe Word64 -> Either (IO YesodRequest) (IO Int -> IO YesodRequest)

-- | Generate a random String of alphanumerical characters (a-z, A-Z, and
--   0-9) of the given length using the given random number generator.
randomString :: Monad m => Int -> m Int -> m Text
mkYesodGeneral :: [[String]] -> String -> [String] -> Bool -> (Exp -> Q Exp) -> [ResourceTree String] -> Q ([Dec], [Dec])

module Yesod.Core.Dispatch

-- | A quasi-quoter to parse a string into a list of <a>Resource</a>s.
--   Checks for overlapping routes, failing if present; use
--   <a>parseRoutesNoCheck</a> to skip the checking. See documentation site
--   for details on syntax.
parseRoutes :: QuasiQuoter

-- | Same as <a>parseRoutes</a>, but performs no overlap checking.
parseRoutesNoCheck :: QuasiQuoter
parseRoutesFile :: FilePath -> Q Exp
parseRoutesFileNoCheck :: FilePath -> Q Exp

-- | Generates URL datatype and site function for the given
--   <a>Resource</a>s. This is used for creating sites, <i>not</i>
--   subsites. See <a>mkYesodSubData</a> and <a>mkYesodSubDispatch</a> for
--   the latter. Use <a>parseRoutes</a> to create the <a>Resource</a>s.
--   
--   Contexts and type variables in the name of the datatype are parsed.
--   For example, a datatype <tt>App a</tt> with typeclass constraint
--   <tt>MyClass a</tt> can be written as <tt>"(MyClass a) =&gt; App
--   a"</tt>.
mkYesod :: String -> [ResourceTree String] -> Q [Dec]

-- | Similar to <a>mkYesod</a>, except contexts and type variables are not
--   parsed. Instead, they are explicitly provided. You can write
--   <tt>(MyClass a) =&gt; App a</tt> with <tt>mkYesodWith
--   [["MyClass","a"]] "App" ["a"] ...</tt>.

-- | <i>Deprecated: Contexts and type variables are now parsed from the
--   name in <a>mkYesod</a>.
--   <a>https://github.com/yesodweb/yesod/pull/1366</a></i>
mkYesodWith :: [[String]] -> String -> [String] -> [ResourceTree String] -> Q [Dec]

-- | Sometimes, you will want to declare your routes in one file and define
--   your handlers elsewhere. For example, this is the only way to break up
--   a monolithic file into smaller parts. Use this function, paired with
--   <a>mkYesodDispatch</a>, to do just that.
mkYesodData :: String -> [ResourceTree String] -> Q [Dec]
mkYesodSubData :: String -> [ResourceTree String] -> Q [Dec]

-- | See <a>mkYesodData</a>.
mkYesodDispatch :: String -> [ResourceTree String] -> Q [Dec]
mkYesodSubDispatch :: [ResourceTree a] -> Q Exp

-- | Default constructor for <a>yreGetMaxExpires</a> field. Low level
--   function for simple manual construction of <a>YesodRunnerEnv</a>.
getGetMaxExpires :: IO (IO Text)
class PathPiece s
fromPathPiece :: PathPiece s => Text -> Maybe s
toPathPiece :: PathPiece s => s -> Text
class PathMultiPiece s
fromPathMultiPiece :: PathMultiPiece s => [Text] -> Maybe s
toPathMultiPiece :: PathMultiPiece s => s -> [Text]
type Texts = [Text]

-- | Same as <a>toWaiAppPlain</a>, but provides a default set of
--   middlewares. This set may change with future releases, but currently
--   covers:
--   
--   <ul>
--   <li>Logging</li>
--   <li>GZIP compression</li>
--   <li>Automatic HEAD method handling</li>
--   <li>Request method override with the _method query string
--   parameter</li>
--   <li>Accept header override with the _accept query string
--   parameter</li>
--   </ul>
toWaiApp :: YesodDispatch site => site -> IO Application

-- | Convert the given argument into a WAI application, executable with any
--   WAI handler. This function will provide no middlewares; if you want
--   commonly used middlewares, please use <a>toWaiApp</a>.
toWaiAppPlain :: YesodDispatch site => site -> IO Application

-- | Pure low level function to construct WAI application. Usefull when you
--   need not standard way to run your app, or want to embed it inside
--   another app.
toWaiAppYre :: YesodDispatch site => YesodRunnerEnv site -> Application

-- | A convenience method to run an application using the Warp webserver on
--   the specified port. Automatically calls <a>toWaiApp</a>. Provides a
--   default set of middlewares. This set may change at any point without a
--   breaking version number. Currently, it includes:
--   
--   If you need more fine-grained control of middlewares, please use
--   <a>toWaiApp</a> directly.
--   
--   Since 1.2.0
warp :: YesodDispatch site => Int -> site -> IO ()

-- | Deprecated synonym for <a>warp</a>.

-- | <i>Deprecated: Please use warp instead</i>
warpDebug :: YesodDispatch site => Int -> site -> IO ()

-- | Runs your application using default middlewares (i.e., via
--   <a>toWaiApp</a>). It reads port information from the PORT environment
--   variable, as used by tools such as Keter and the FP Complete School of
--   Haskell.
--   
--   Note that the exact behavior of this function may be modified slightly
--   over time to work correctly with external tools, without a change to
--   the type signature.
warpEnv :: YesodDispatch site => site -> IO ()

-- | A default set of middlewares.
--   
--   Since 1.2.0
mkDefaultMiddlewares :: Logger -> IO Middleware

-- | All of the default middlewares, excluding logging.
--   
--   Since 1.2.12
defaultMiddlewaresNoLogging :: Middleware

-- | Wrap up a normal WAI application as a Yesod subsite. Ignore parent
--   site's middleware and isAuthorized.
newtype WaiSubsite
WaiSubsite :: Application -> WaiSubsite
[runWaiSubsite] :: WaiSubsite -> Application

-- | Like <a>WaiSubsite</a>, but applies parent site's middleware and
--   isAuthorized.
newtype WaiSubsiteWithAuth
WaiSubsiteWithAuth :: Application -> WaiSubsiteWithAuth
[runWaiSubsiteWithAuth] :: WaiSubsiteWithAuth -> Application

module Yesod.Core

-- | Define settings for a Yesod applications. All methods have intelligent
--   defaults, and therefore no implementation is required.
class RenderRoute site => Yesod site

-- | An absolute URL to the root of the application. Do not include
--   trailing slash.
--   
--   Default value: <a>guessApproot</a>. If you know your application root
--   statically, it will be more efficient and more reliable to instead use
--   <a>ApprootStatic</a> or <a>ApprootMaster</a>. If you do not need full
--   absolute URLs, you can use <a>ApprootRelative</a> instead.
--   
--   Note: Prior to yesod-core 1.5, the default value was
--   <a>ApprootRelative</a>.
approot :: Yesod site => Approot site

-- | Output error response pages.
--   
--   Default value: <a>defaultErrorHandler</a>.
errorHandler :: Yesod site => ErrorResponse -> HandlerFor site TypedContent

-- | Applies some form of layout to the contents of a page.
defaultLayout :: Yesod site => WidgetFor site () -> HandlerFor site Html

-- | Override the rendering function for a particular URL and query string
--   parameters. One use case for this is to offload static hosting to a
--   different domain name to avoid sending cookies.
--   
--   For backward compatibility default implementation is in terms of
--   <tt>urlRenderOverride</tt>, probably ineffective
--   
--   Since 1.4.23
urlParamRenderOverride :: Yesod site => site -> Route site -> [(Text, Text)] -> Maybe Builder

-- | Determine if a request is authorized or not.
--   
--   Return <a>Authorized</a> if the request is authorized,
--   <a>Unauthorized</a> a message if unauthorized. If authentication is
--   required, return <a>AuthenticationRequired</a>.
isAuthorized :: Yesod site => Route site -> Bool -> HandlerFor site AuthResult

-- | Determines whether the current request is a write request. By default,
--   this assumes you are following RESTful principles, and determines this
--   from request method. In particular, all except the following request
--   methods are considered write: GET HEAD OPTIONS TRACE.
--   
--   This function is used to determine if a request is authorized; see
--   <a>isAuthorized</a>.
isWriteRequest :: Yesod site => Route site -> HandlerFor site Bool

-- | The default route for authentication.
--   
--   Used in particular by <a>isAuthorized</a>, but library users can do
--   whatever they want with it.
authRoute :: Yesod site => site -> Maybe (Route site)

-- | A function used to clean up path segments. It returns <a>Right</a>
--   with a clean path or <a>Left</a> with a new set of pieces the user
--   should be redirected to. The default implementation enforces:
--   
--   <ul>
--   <li>No double slashes</li>
--   <li>There is no trailing slash.</li>
--   </ul>
--   
--   Note that versions of Yesod prior to 0.7 used a different set of rules
--   involing trailing slashes.
cleanPath :: Yesod site => site -> [Text] -> Either [Text] [Text]

-- | Builds an absolute URL by concatenating the application root with the
--   pieces of a path and a query string, if any. Note that the pieces of
--   the path have been previously cleaned up by <a>cleanPath</a>.
joinPath :: Yesod site => site -> Text -> [Text] -> [(Text, Text)] -> Builder

-- | This function is used to store some static content to be served as an
--   external file. The most common case of this is stashing CSS and
--   JavaScript content in an external file; the <a>Yesod.Widget</a> module
--   uses this feature.
--   
--   The return value is <a>Nothing</a> if no storing was performed; this
--   is the default implementation. A <a>Just</a> <a>Left</a> gives the
--   absolute URL of the file, whereas a <a>Just</a> <a>Right</a> gives the
--   type-safe URL. The former is necessary when you are serving the
--   content outside the context of a Yesod application, such as via
--   memcached.
addStaticContent :: Yesod site => Text -> Text -> ByteString -> HandlerFor site (Maybe (Either Text (Route site, [(Text, Text)])))

-- | Maximum allowed length of the request body, in bytes. This method may
--   be ignored if <a>maximumContentLengthIO</a> is overridden.
--   
--   If <tt>Nothing</tt>, no maximum is applied.
--   
--   Default: 2 megabytes.
maximumContentLength :: Yesod site => site -> Maybe (Route site) -> Maybe Word64

-- | Maximum allowed length of the request body, in bytes. This is similar
--   to <a>maximumContentLength</a>, but the result lives in <tt>IO</tt>.
--   This allows you to dynamically change the maximum file size based on
--   some external source like a database or an <tt>IORef</tt>.
--   
--   The default implementation uses <a>maximumContentLength</a>. Future
--   version of yesod will remove <a>maximumContentLength</a> and use this
--   method exclusively.
maximumContentLengthIO :: Yesod site => site -> Maybe (Route site) -> IO (Maybe Word64)

-- | Creates a <tt>Logger</tt> to use for log messages.
--   
--   Note that a common technique (endorsed by the scaffolding) is to
--   create a <tt>Logger</tt> value and place it in your foundation
--   datatype, and have this method return that already created value. That
--   way, you can use that same <tt>Logger</tt> for printing messages
--   during app initialization.
--   
--   Default: the <a>defaultMakeLogger</a> function.
makeLogger :: Yesod site => site -> IO Logger

-- | Send a message to the <tt>Logger</tt> provided by <tt>getLogger</tt>.
--   
--   Default: the <a>defaultMessageLoggerSource</a> function, using
--   <a>shouldLogIO</a> to check whether we should log.
messageLoggerSource :: Yesod site => site -> Logger -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | Where to Load sripts from. We recommend the default value,
--   <a>BottomOfBody</a>.
jsLoader :: Yesod site => site -> ScriptLoadPosition site

-- | Default attributes to put on the JavaScript <a>script</a> tag
--   generated for julius files
jsAttributes :: Yesod site => site -> [(Text, Text)]

-- | Same as <tt>jsAttributes</tt> but allows you to run arbitrary Handler
--   code
--   
--   This is useful if you need to add a randomised nonce value to the
--   script tag generated by <tt>widgetFile</tt>. If this function is
--   overridden then <tt>jsAttributes</tt> is ignored.
jsAttributesHandler :: Yesod site => HandlerFor site [(Text, Text)]

-- | Create a session backend. Returning <a>Nothing</a> disables sessions.
--   If you'd like to change the way that the session cookies are created,
--   take a look at <a>customizeSessionCookies</a>.
--   
--   Default: Uses clientsession with a 2 hour timeout.
makeSessionBackend :: Yesod site => site -> IO (Maybe SessionBackend)

-- | How to store uploaded files.
--   
--   Default: When the request body is greater than 50kb, store in a temp
--   file. For chunked request bodies, store in a temp file. Otherwise,
--   store in memory.
fileUpload :: Yesod site => site -> RequestBodyLength -> FileUpload

-- | Should we log the given log source/level combination.
--   
--   Default: the <a>defaultShouldLogIO</a> function.
--   
--   Since 1.2.4
shouldLogIO :: Yesod site => site -> LogSource -> LogLevel -> IO Bool

-- | A Yesod middleware, which will wrap every handler function. This
--   allows you to run code before and after a normal handler.
--   
--   Default: the <a>defaultYesodMiddleware</a> function.
--   
--   Since: 1.1.6
yesodMiddleware :: (Yesod site, ToTypedContent res) => HandlerFor site res -> HandlerFor site res

-- | How to allocate an <tt>InternalState</tt> for each request.
--   
--   The default implementation is almost always what you want. However, if
--   you know that you are never taking advantage of the
--   <tt>MonadResource</tt> instance in your handler functions, setting
--   this to a dummy implementation can provide a small optimization. Only
--   do this if you really know what you're doing, otherwise you can turn
--   safe code into a runtime error!
--   
--   Since 1.4.2
yesodWithInternalState :: Yesod site => site -> Maybe (Route site) -> (InternalState -> IO a) -> IO a

-- | Convert a title and HTML snippet into a <tt>Widget</tt>. Used
--   primarily for wrapping up error messages for better display.
defaultMessageWidget :: Yesod site => Html -> HtmlUrl (Route site) -> WidgetFor site ()

-- | This class is automatically instantiated when you use the template
--   haskell mkYesod function. You should never need to deal with it
--   directly.
class Yesod site => YesodDispatch site
yesodDispatch :: YesodDispatch site => YesodRunnerEnv site -> Application
class YesodSubDispatch sub master
yesodSubDispatch :: YesodSubDispatch sub master => YesodSubRunnerEnv sub master -> Application
class Eq (Route a) => RenderRoute a where {
    
    -- | The <a>type-safe URLs</a> associated with a site argument.
    data family Route a;
}
renderRoute :: RenderRoute a => Route a -> ([Text], [(Text, Text)])
class RenderRoute a => ParseRoute a
parseRoute :: ParseRoute a => ([Text], [(Text, Text)]) -> Maybe (Route a)
class RenderRoute a => RouteAttrs a
routeAttrs :: RouteAttrs a => Route a -> Set Text

-- | A type-safe, concise method of creating breadcrumbs for pages. For
--   each resource, you declare the title of the page and the parent
--   resource (if present).
class YesodBreadcrumbs site

-- | Returns the title and the parent resource, if available. If you return
--   a <a>Nothing</a>, then this is considered a top-level page.
breadcrumb :: YesodBreadcrumbs site => Route site -> HandlerFor site (Text, Maybe (Route site))

-- | Gets the title of the current page and the hierarchy of parent pages,
--   along with their respective titles.
breadcrumbs :: YesodBreadcrumbs site => HandlerFor site (Text, [(Route site, Text)])

-- | How to determine the root of the application for constructing URLs.
--   
--   Note that future versions of Yesod may add new constructors without
--   bumping the major version number. As a result, you should <i>not</i>
--   pattern match on <tt>Approot</tt> values.
data Approot master

-- | No application root.
ApprootRelative :: Approot master
ApprootStatic :: !Text -> Approot master
ApprootMaster :: !master -> Text -> Approot master
ApprootRequest :: !master -> Request -> Text -> Approot master
data FileUpload
FileUploadMemory :: !BackEnd ByteString -> FileUpload
FileUploadDisk :: !InternalState -> BackEnd FilePath -> FileUpload
FileUploadSource :: !BackEnd (ConduitT () ByteString (ResourceT IO) ()) -> FileUpload

-- | Responses to indicate some form of an error occurred.
data ErrorResponse
NotFound :: ErrorResponse
InternalError :: !Text -> ErrorResponse
InvalidArgs :: ![Text] -> ErrorResponse
NotAuthenticated :: ErrorResponse
PermissionDenied :: !Text -> ErrorResponse
BadMethod :: !Method -> ErrorResponse

-- | Return the same URL if the user is authorized to see it.
--   
--   Built on top of <a>isAuthorized</a>. This is useful for building page
--   that only contain links to pages the user is allowed to see.
maybeAuthorized :: Yesod site => Route site -> Bool -> HandlerT site IO (Maybe (Route site))

-- | Convert a widget to a <a>PageContent</a>.
widgetToPageContent :: Yesod site => WidgetFor site () -> HandlerFor site (PageContent (Route site))

-- | The default error handler for <a>errorHandler</a>.
defaultErrorHandler :: Yesod site => ErrorResponse -> HandlerFor site TypedContent

-- | Default implementation of <a>yesodMiddleware</a>. Adds the response
--   header "Vary: Accept, Accept-Language", "X-XSS-Protection: 1;
--   mode=block", and performs authorization checks.
--   
--   Since 1.2.0
defaultYesodMiddleware :: Yesod site => HandlerFor site res -> HandlerFor site res

-- | Check if a given request is authorized via <a>isAuthorized</a> and
--   <a>isWriteRequest</a>.
--   
--   Since 1.2.0
authorizationCheck :: Yesod site => HandlerFor site ()
data AuthResult
Authorized :: AuthResult
AuthenticationRequired :: AuthResult
Unauthorized :: !Text -> AuthResult

-- | Return an <a>Unauthorized</a> value, with the given i18n message.
unauthorizedI :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => msg -> m AuthResult

-- | Default implementation of <a>makeLogger</a>. Sends to stdout and
--   automatically flushes on each write.
--   
--   Since 1.4.10
defaultMakeLogger :: IO Logger

-- | Default implementation of <a>messageLoggerSource</a>. Checks if the
--   message should be logged using the provided function, and if so,
--   formats using <a>formatLogMessage</a>. You can use
--   <a>defaultShouldLogIO</a> as the provided function.
--   
--   Since 1.4.10
defaultMessageLoggerSource :: (LogSource -> LogLevel -> IO Bool) -> Logger -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | Default implementation of <tt>shouldLog</tt>. Logs everything at or
--   above <a>LevelInfo</a>.
--   
--   Since 1.4.10
defaultShouldLogIO :: LogSource -> LogLevel -> IO Bool

-- | Default formatting for log messages. When you use the template haskell
--   logging functions for to log with information about the source
--   location, that information will be appended to the end of the log.
--   When you use the non-TH logging functions, like <tt>logDebugN</tt>,
--   this function does not include source information. This currently
--   works by checking to see if the package name is the string
--   "&lt;unknown&gt;". This is a hack, but it removes some of the visual
--   clutter from non-TH logs.
--   
--   Since 1.4.10
formatLogMessage :: IO ZonedDate -> Loc -> LogSource -> LogLevel -> LogStr -> IO LogStr
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: Text -> LogLevel

-- | Generates a function that takes a <a>Text</a> and logs a
--   <a>LevelDebug</a> message. Usage:
--   
--   <pre>
--   $(logDebug) "This is a debug log message"
--   </pre>
logDebug :: Q Exp

-- | See <a>logDebug</a>
logInfo :: Q Exp

-- | See <a>logDebug</a>
logWarn :: Q Exp

-- | See <a>logDebug</a>
logError :: Q Exp

-- | Generates a function that takes a <a>Text</a> and logs a
--   <a>LevelOther</a> message. Usage:
--   
--   <pre>
--   $(logOther "My new level") "This is a log message"
--   </pre>
logOther :: Text -> Q Exp

-- | Generates a function that takes a <a>LogSource</a> and <a>Text</a> and
--   logs a <a>LevelDebug</a> message. Usage:
--   
--   <pre>
--   $logDebugS "SomeSource" "This is a debug log message"
--   </pre>
logDebugS :: Q Exp

-- | See <a>logDebugS</a>
logInfoS :: Q Exp

-- | See <a>logDebugS</a>
logWarnS :: Q Exp

-- | See <a>logDebugS</a>
logErrorS :: Q Exp

-- | Generates a function that takes a <a>LogSource</a>, a level name and a
--   <a>Text</a> and logs a <a>LevelOther</a> message. Usage:
--   
--   <pre>
--   $logOtherS "SomeSource" "My new level" "This is a log message"
--   </pre>
logOtherS :: Q Exp
newtype SessionBackend
SessionBackend :: (Request -> IO (SessionMap, SaveSession)) -> SessionBackend

-- | Return the session data and a function to save the session
[sbLoadSession] :: SessionBackend -> Request -> IO (SessionMap, SaveSession)

-- | Customize the cookies used by the session backend. You may use this
--   function on your definition of <a>makeSessionBackend</a>.
--   
--   For example, you could set the cookie domain so that it would work
--   across many subdomains:
--   
--   <pre>
--   makeSessionBackend site =
--       (fmap . fmap) (customizeSessionCookies addDomain) ...
--     where
--       addDomain cookie = cookie { <a>setCookieDomain</a> = Just ".example.com" }
--   </pre>
--   
--   Default: Do not customize anything (<a>id</a>).
customizeSessionCookies :: (SetCookie -> SetCookie) -> SessionBackend -> SessionBackend
defaultClientSessionBackend :: Int -> FilePath -> IO SessionBackend

-- | Create a <tt>SessionBackend</tt> which reads the session key from the
--   named environment variable.
--   
--   This can be useful if:
--   
--   <ol>
--   <li>You can't rely on a persistent file system (e.g. Heroku)</li>
--   <li>Your application is open source (e.g. you can't commit the
--   key)</li>
--   </ol>
--   
--   By keeping a consistent value in the environment variable, your users
--   will have consistent sessions without relying on the file system.
--   
--   Note: A suitable value should only be obtained in one of two ways:
--   
--   <ol>
--   <li>Run this code without the variable set, a value will be generated
--   and printed on <tt><i>dev</i>stdout/</tt></li>
--   <li>Use <tt>clientsession-generate</tt></li>
--   </ol>
--   
--   Since 1.4.5
envClientSessionBackend :: Int -> String -> IO SessionBackend
clientSessionBackend :: Key -> IO ClientSessionDateCache -> SessionBackend

-- | Defends against session hijacking by setting the secure bit on session
--   cookies so that browsers will not transmit them over http. With this
--   setting on, it follows that the server will regard requests made over
--   http as sessionless, because the session cookie will not be included
--   in the request. Use this as part of a total security measure which
--   also includes disabling HTTP traffic to the site or issuing redirects
--   from HTTP urls, and composing <a>sslOnlyMiddleware</a> with the site's
--   <a>yesodMiddleware</a>.
--   
--   Since 1.4.7
sslOnlySessions :: IO (Maybe SessionBackend) -> IO (Maybe SessionBackend)

-- | Helps defend against CSRF attacks by setting the SameSite attribute on
--   session cookies to Lax. With the Lax setting, the cookie will be sent
--   with same-site requests, and with cross-site top-level navigations.
--   
--   This option is liable to change in future versions of Yesod as the
--   spec evolves. View more information <a>here</a>.
laxSameSiteSessions :: IO (Maybe SessionBackend) -> IO (Maybe SessionBackend)

-- | Helps defend against CSRF attacks by setting the SameSite attribute on
--   session cookies to Strict. With the Strict setting, the cookie will
--   only be sent with same-site requests.
--   
--   This option is liable to change in future versions of Yesod as the
--   spec evolves. View more information <a>here</a>.
strictSameSiteSessions :: IO (Maybe SessionBackend) -> IO (Maybe SessionBackend)

-- | Apply a Strict-Transport-Security header with the specified timeout to
--   all responses so that browsers will rewrite all http links to https
--   until the timeout expires. For security, the max-age of the STS header
--   should always equal or exceed the client sessions timeout. This
--   defends against SSL-stripping man-in-the-middle attacks. It is only
--   effective if a secure connection has already been made;
--   Strict-Transport-Security headers are ignored over HTTP.
--   
--   Since 1.4.7
sslOnlyMiddleware :: Int -> HandlerFor site res -> HandlerFor site res
clientSessionDateCacher :: NominalDiffTime -> IO (IO ClientSessionDateCache, IO ())
loadClientSession :: Key -> IO ClientSessionDateCache -> ByteString -> Request -> IO (SessionMap, SaveSession)

-- | Headers to be added to a <tt>Result</tt>.
data Header
AddCookie :: !SetCookie -> Header

-- | name and path
DeleteCookie :: !ByteString -> !ByteString -> Header

-- | key and value
Header :: !CI ByteString -> !ByteString -> Header

-- | Calls <a>defaultCsrfSetCookieMiddleware</a> and
--   <a>defaultCsrfCheckMiddleware</a>.
--   
--   For details, see the "AJAX CSRF protection" section of
--   <a>Yesod.Core.Handler</a>.
--   
--   You can chain this middleware together with other middleware like so:
--   
--   <pre>
--   <a>yesodMiddleware</a> = <a>defaultYesodMiddleware</a> . <a>defaultCsrfMiddleware</a>
--   </pre>
--   
--   or:
--   
--   <pre>
--   <a>yesodMiddleware</a> app = <a>defaultYesodMiddleware</a> $ <a>defaultCsrfMiddleware</a> $ app
--   </pre>
--   
--   Since 1.4.14
defaultCsrfMiddleware :: Yesod site => HandlerFor site res -> HandlerFor site res

-- | Calls <a>csrfSetCookieMiddleware</a> with the
--   <a>defaultCsrfCookieName</a>.
--   
--   The cookie's path is set to <tt>/</tt>, making it valid for your whole
--   website.
--   
--   Since 1.4.14
defaultCsrfSetCookieMiddleware :: HandlerFor site res -> HandlerFor site res

-- | Takes a <a>SetCookie</a> and overrides its value with a CSRF token,
--   then sets the cookie. See <a>setCsrfCookieWithCookie</a>.
--   
--   For details, see the "AJAX CSRF protection" section of
--   <a>Yesod.Core.Handler</a>.
--   
--   Make sure to set the <a>setCookiePath</a> to the root path of your
--   application, otherwise you'll generate a new CSRF token for every path
--   of your app. If your app is run from from e.g. www.example.com/app1,
--   use <tt>app1</tt>. The vast majority of sites will just use
--   <tt>/</tt>.
--   
--   Since 1.4.14
csrfSetCookieMiddleware :: HandlerFor site res -> SetCookie -> HandlerFor site res

-- | Calls <a>csrfCheckMiddleware</a> with <a>isWriteRequest</a>,
--   <a>defaultCsrfHeaderName</a>, and <a>defaultCsrfParamName</a> as
--   parameters.
--   
--   Since 1.4.14
defaultCsrfCheckMiddleware :: Yesod site => HandlerFor site res -> HandlerFor site res

-- | Looks up the CSRF token from the request headers or POST parameters.
--   If the value doesn't match the token stored in the session, this
--   function throws a <a>PermissionDenied</a> error.
--   
--   For details, see the "AJAX CSRF protection" section of
--   <a>Yesod.Core.Handler</a>.
--   
--   Since 1.4.14
csrfCheckMiddleware :: HandlerFor site res -> HandlerFor site Bool -> CI ByteString -> Text -> HandlerFor site res
data ScriptLoadPosition master
BottomOfBody :: ScriptLoadPosition master
BottomOfHeadBlocking :: ScriptLoadPosition master
BottomOfHeadAsync :: !BottomOfHeadAsync master -> ScriptLoadPosition master
type BottomOfHeadAsync master = [Text] " urls to load asynchronously" -> Maybe (HtmlUrl (Route master)) " widget of js to run on async completion" -> HtmlUrl (Route master) " widget to insert at the bottom of <head>"
class (MonadResource m, MonadLogger m) => MonadHandler m where {
    type family HandlerSite m;
    type family SubHandlerSite m;
}
liftHandler :: MonadHandler m => HandlerFor (HandlerSite m) a -> m a
liftSubHandler :: MonadHandler m => SubHandlerFor (SubHandlerSite m) (HandlerSite m) a -> m a
class MonadHandler m => MonadWidget m
liftWidget :: MonadWidget m => WidgetFor (HandlerSite m) a -> m a

-- | Guess the approot based on request headers. For more information, see
--   <a>Network.Wai.Middleware.Approot</a>
--   
--   In the case of headers being unavailable, it falls back to
--   <a>ApprootRelative</a>
--   
--   Since 1.4.16
guessApproot :: Approot site

-- | Guess the approot based on request headers, with fall back to the
--   specified <tt>AppRoot</tt>.
--   
--   Since 1.4.16
guessApprootOr :: Approot site -> Approot site

-- | Get the textual application root from an <a>Approot</a> value.
--   
--   Since 1.4.17
getApprootText :: Approot site -> site -> Request -> Text
yesodVersion :: String
yesodRender :: Yesod y => y -> ResolvedApproot -> Route y -> [(Text, Text)] -> Text

-- | <i>Deprecated: import runFakeHandler from Yesod.Core.Unsafe</i>
runFakeHandler :: (Yesod site, MonadIO m) => SessionMap -> (site -> Logger) -> site -> HandlerT site IO a -> m (Either ErrorResponse a)
newtype LiteApp
LiteApp :: (Method -> [Text] -> Maybe (LiteHandler TypedContent)) -> LiteApp
[unLiteApp] :: LiteApp -> Method -> [Text] -> Maybe (LiteHandler TypedContent)
type LiteHandler = HandlerFor LiteApp
type LiteWidget = WidgetFor LiteApp
liteApp :: Writer LiteApp () -> LiteApp
dispatchTo :: ToTypedContent a => LiteHandler a -> Writer LiteApp ()
onMethod :: Method -> Writer LiteApp () -> Writer LiteApp ()
onStatic :: Text -> Writer LiteApp () -> Writer LiteApp ()
withDynamic :: PathPiece p => (p -> Writer LiteApp ()) -> Writer LiteApp ()
withDynamicMulti :: PathMultiPiece ps => (ps -> Writer LiteApp ()) -> Writer LiteApp ()
yesodRunner :: (ToTypedContent res, Yesod site) => HandlerFor site res -> YesodRunnerEnv site -> Maybe (Route site) -> Application

-- | Format a <a>UTCTime</a> in W3 format.
formatW3 :: UTCTime -> Text

-- | Format as per RFC 1123.
formatRFC1123 :: UTCTime -> Text

-- | Format as per RFC 822.
formatRFC822 :: UTCTime -> Text

-- | Convert a value to Markup without escaping
preEscapedToMarkup :: ToMarkup a => a -> Markup
toHtml :: ToMarkup a => a -> Html
type Html = Markup

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Monads which allow their actions to be run in <a>IO</a>.
--   
--   While <a>MonadIO</a> allows an <a>IO</a> action to be lifted into
--   another monad, this class captures the opposite concept: allowing you
--   to capture the monadic context. Note that, in order to meet the laws
--   given below, the intuition is that a monad must have no monadic state,
--   but may have monadic context. This essentially limits
--   <a>MonadUnliftIO</a> to <a>ReaderT</a> and <a>IdentityT</a>
--   transformers on top of <a>IO</a>.
--   
--   Laws. For any value <tt>u</tt> returned by <a>askUnliftIO</a>, it must
--   meet the monad transformer laws as reformulated for
--   <tt>MonadUnliftIO</tt>:
--   
--   <ul>
--   <li><pre>unliftIO u . return = return</pre></li>
--   <li><pre>unliftIO u (m &gt;&gt;= f) = unliftIO u m &gt;&gt;= unliftIO
--   u . f</pre></li>
--   </ul>
--   
--   The third is a currently nameless law which ensures that the current
--   context is preserved.
--   
--   <ul>
--   <li><pre>askUnliftIO &gt;&gt;= (u -&gt; liftIO (unliftIO u m)) =
--   m</pre></li>
--   </ul>
--   
--   If you have a name for this, please submit it in a pull request for
--   great glory.
class MonadIO m => MonadUnliftIO (m :: Type -> Type)

-- | Capture the current monadic context, providing the ability to run
--   monadic actions in <a>IO</a>.
--   
--   See <a>UnliftIO</a> for an explanation of why we need a helper
--   datatype here.
askUnliftIO :: MonadUnliftIO m => m (UnliftIO m)

-- | Convenience function for capturing the monadic context and running an
--   <a>IO</a> action with a runner function. The runner function is used
--   to run a monadic action <tt>m</tt> in <tt>IO</tt>.
withRunInIO :: MonadUnliftIO m => ((forall a. () => m a -> IO a) -> IO b) -> m b

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack which includes a <tt>ResourceT</tt> can be
--   an instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a <tt>MonadUnliftIO
--   m</tt> monad, which allows control operations to be lifted. A
--   <tt>MonadResource</tt> does not have this requirement. This means that
--   transformers such as <tt>ContT</tt> can be an instance of
--   <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will need
--   to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class MonadIO m => MonadResource (m :: Type -> Type)

-- | Lift a <tt>ResourceT IO</tt> action into the current <tt>Monad</tt>.
--   
--   Since 0.4.0
liftResourceT :: MonadResource m => ResourceT IO a -> m a

-- | A <tt>Monad</tt> which has the ability to log messages in some manner.
class Monad m => MonadLogger (m :: Type -> Type)

-- | The WAI application.
--   
--   Note that, since WAI 3.0, this type is structured in continuation
--   passing style to allow for proper safe resource handling. This was
--   handled in the past via other means (e.g., <tt>ResourceT</tt>). As a
--   demonstration:
--   
--   <pre>
--   app :: Application
--   app req respond = bracket_
--       (putStrLn "Allocating scarce resource")
--       (putStrLn "Cleaning up")
--       (respond $ responseLBS status200 [] "Hello World")
--   </pre>
type Application = Request -> Response -> IO ResponseReceived -> IO ResponseReceived
showIntegral :: Integral a => a -> String
readIntegral :: Num a => String -> Maybe a

-- | Hamlet quasi-quoter. May only be used to generate expressions.
--   
--   Generated expression have type <tt><a>HtmlUrl</a> url</tt>, for some
--   <tt>url</tt>.
--   
--   <pre>
--   data MyRoute = Home
--   
--   render :: <a>Render</a> MyRoute
--   render Home _ = "/home"
--   
--   &gt;&gt;&gt; <a>putStrLn</a> (<a>renderHtml</a> ([<a>hamlet</a>|&lt;a href=@{Home}&gt;Home|] render))
--   &lt;a href="/home"&gt;Home&lt;/a&gt;
--   </pre>
hamlet :: QuasiQuoter

-- | "Simple Hamlet" quasi-quoter. May only be used to generate
--   expressions.
--   
--   Generated expressions have type <a>Html</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>putStrLn</a> (<a>renderHtml</a> [<a>shamlet</a>|&lt;div&gt;Hello, world!|])
--   &lt;div&gt;Hello, world!&lt;/div&gt;
--   </pre>
shamlet :: QuasiQuoter

-- | Like <a>hamlet</a>, but produces XHTML.
xhamlet :: QuasiQuoter

-- | A function generating an <a>Html</a> given a URL-rendering function.
type HtmlUrl url = Render url -> Html
julius :: QuasiQuoter

-- | Return type of template-reading functions.
type JavascriptUrl url = url -> [(Text, Text)] -> Text -> Javascript

-- | render with route interpolation. If using this module standalone,
--   apart from type-safe routes, a dummy renderer can be used:
--   
--   <pre>
--   renderJavascriptUrl (\_ _ -&gt; undefined) javascriptUrl
--   </pre>
--   
--   When using Yesod, a renderer is generated for you, which can be
--   accessed within the GHandler monad: <a>getUrlRenderParams</a>.
renderJavascriptUrl :: () => (url -> [(Text, Text)] -> Text) -> JavascriptUrl url -> Text
cassius :: QuasiQuoter

-- | <pre>
--   &gt;&gt;&gt; renderCss ([lucius|foo{bar:baz}|] undefined)
--   "foo{bar:baz}"
--   </pre>
lucius :: QuasiQuoter
type CssUrl url = url -> [(Text, Text)] -> Text -> Css
renderCssUrl :: () => (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text
