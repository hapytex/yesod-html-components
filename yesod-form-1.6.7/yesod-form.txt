-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Form handling support for Yesod Web Framework
--   
--   API docs and the README are available at
--   <a>http://www.stackage.org/package/yesod-form</a>. Third-party
--   packages which you can find useful: <a>yesod-form-richtext</a> -
--   richtext form fields (currntly it provides only Summernote support).
@package yesod-form
@version 1.6.7

module Yesod.Form.Types

-- | The encoding type required by a form. The <tt>ToHtml</tt> instance
--   produces values that can be inserted directly into HTML.
data Enctype
UrlEncoded :: Enctype
Multipart :: Enctype

-- | A form can produce three different results: there was no data
--   available, the data was invalid, or there was a successful parse.
--   
--   The <a>Applicative</a> instance will concatenate the failure messages
--   in two <a>FormResult</a>s. The <a>Alternative</a> instance will choose
--   <a>FormFailure</a> before <a>FormSuccess</a>, and <a>FormMissing</a>
--   last of all.
data FormResult a
FormMissing :: FormResult a
FormFailure :: [Text] -> FormResult a
FormSuccess :: a -> FormResult a
data FormMessage
MsgInvalidInteger :: Text -> FormMessage
MsgInvalidNumber :: Text -> FormMessage
MsgInvalidEntry :: Text -> FormMessage
MsgInvalidUrl :: Text -> FormMessage
MsgInvalidEmail :: Text -> FormMessage
MsgInvalidTimeFormat :: FormMessage
MsgInvalidHour :: Text -> FormMessage
MsgInvalidMinute :: Text -> FormMessage
MsgInvalidSecond :: Text -> FormMessage
MsgInvalidDay :: FormMessage
MsgCsrfWarning :: FormMessage
MsgValueRequired :: FormMessage
MsgInputNotFound :: Text -> FormMessage
MsgSelectNone :: FormMessage
MsgInvalidBool :: Text -> FormMessage
MsgBoolYes :: FormMessage
MsgBoolNo :: FormMessage
MsgDelete :: FormMessage
type Env = Map Text [Text]
type FileEnv = Map Text [FileInfo]
data Ints
IntCons :: Int -> Ints -> Ints
IntSingle :: Int -> Ints

-- | <a>MForm</a> variant stacking a <a>WriterT</a>. The following code
--   example using a monadic form <a>MForm</a>:
--   
--   <pre>
--   formToAForm $ do
--     (field1F, field1V) &lt;- mreq textField MsgField1 Nothing
--     (field2F, field2V) &lt;- mreq (checkWith field1F textField) MsgField2 Nothing
--     (field3F, field3V) &lt;- mreq (checkWith field1F textField) MsgField3 Nothing
--     return
--       ( MyForm &lt;$&gt; field1F &lt;*&gt; field2F &lt;*&gt; field3F
--       , [field1V, field2V, field3V]
--       )
--   </pre>
--   
--   Could be rewritten as follows using <a>WForm</a>:
--   
--   <pre>
--   wFormToAForm $ do
--     field1F &lt;- wreq textField MsgField1 Nothing
--     field2F &lt;- wreq (checkWith field1F textField) MsgField2 Nothing
--     field3F &lt;- wreq (checkWith field1F textField) MsgField3 Nothing
--     return $ MyForm &lt;$&gt; field1F &lt;*&gt; field2F &lt;*&gt; field3F
--   </pre>
type WForm m a = MForm (WriterT [FieldView (HandlerSite m)] m) a
type MForm m a = RWST (Maybe (Env, FileEnv), HandlerSite m, [Lang]) Enctype Ints m a
newtype AForm m a
AForm :: ((HandlerSite m, [Text]) -> Maybe (Env, FileEnv) -> Ints -> m (FormResult a, [FieldView (HandlerSite m)] -> [FieldView (HandlerSite m)], Ints, Enctype)) -> AForm m a
[unAForm] :: AForm m a -> (HandlerSite m, [Text]) -> Maybe (Env, FileEnv) -> Ints -> m (FormResult a, [FieldView (HandlerSite m)] -> [FieldView (HandlerSite m)], Ints, Enctype)
data Field m a
Field :: ([Text] -> [FileInfo] -> m (Either (SomeMessage (HandlerSite m)) (Maybe a))) -> FieldViewFunc m a -> Enctype -> Field m a
[fieldParse] :: Field m a -> [Text] -> [FileInfo] -> m (Either (SomeMessage (HandlerSite m)) (Maybe a))
[fieldView] :: Field m a -> FieldViewFunc m a
[fieldEnctype] :: Field m a -> Enctype
data FieldSettings master
FieldSettings :: SomeMessage master -> Maybe (SomeMessage master) -> Maybe Text -> Maybe Text -> [(Text, Text)] -> FieldSettings master
[fsLabel] :: FieldSettings master -> SomeMessage master
[fsTooltip] :: FieldSettings master -> Maybe (SomeMessage master)
[fsId] :: FieldSettings master -> Maybe Text
[fsName] :: FieldSettings master -> Maybe Text
[fsAttrs] :: FieldSettings master -> [(Text, Text)]
data FieldView site
FieldView :: Markup -> Maybe Markup -> Text -> WidgetFor site () -> Maybe Markup -> Bool -> FieldView site
[fvLabel] :: FieldView site -> Markup
[fvTooltip] :: FieldView site -> Maybe Markup
[fvId] :: FieldView site -> Text
[fvInput] :: FieldView site -> WidgetFor site ()
[fvErrors] :: FieldView site -> Maybe Markup
[fvRequired] :: FieldView site -> Bool
type FieldViewFunc m a = Text " ID" -> Text " Name" -> [(Text, Text)] " Attributes" -> Either Text a " Either (invalid text) or (legitimate result)" -> Bool " Required?" -> WidgetFor (HandlerSite m) ()
instance GHC.Read.Read Yesod.Form.Types.FormMessage
instance GHC.Classes.Eq Yesod.Form.Types.FormMessage
instance GHC.Show.Show Yesod.Form.Types.FormMessage
instance GHC.Enum.Bounded Yesod.Form.Types.Enctype
instance GHC.Enum.Enum Yesod.Form.Types.Enctype
instance GHC.Classes.Eq Yesod.Form.Types.Enctype
instance GHC.Classes.Eq a => GHC.Classes.Eq (Yesod.Form.Types.FormResult a)
instance GHC.Show.Show a => GHC.Show.Show (Yesod.Form.Types.FormResult a)
instance GHC.Base.Monad m => GHC.Base.Functor (Yesod.Form.Types.AForm m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Yesod.Form.Types.AForm m)
instance (GHC.Base.Monad m, GHC.Base.Monoid a) => GHC.Base.Monoid (Yesod.Form.Types.AForm m a)
instance (GHC.Base.Monad m, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Yesod.Form.Types.AForm m a)
instance Control.Monad.Trans.Class.MonadTrans Yesod.Form.Types.AForm
instance Data.String.IsString (Yesod.Form.Types.FieldSettings a)
instance GHC.Show.Show Yesod.Form.Types.Ints
instance Text.Blaze.ToMarkup Yesod.Form.Types.Enctype
instance Text.Blaze.ToValue Yesod.Form.Types.Enctype
instance GHC.Base.Monoid Yesod.Form.Types.Enctype
instance GHC.Base.Semigroup Yesod.Form.Types.Enctype
instance GHC.Base.Functor Yesod.Form.Types.FormResult
instance GHC.Base.Applicative Yesod.Form.Types.FormResult
instance GHC.Base.Monoid m => GHC.Base.Monoid (Yesod.Form.Types.FormResult m)
instance GHC.Base.Semigroup m => GHC.Base.Semigroup (Yesod.Form.Types.FormResult m)
instance Data.Foldable.Foldable Yesod.Form.Types.FormResult
instance Data.Traversable.Traversable Yesod.Form.Types.FormResult
instance GHC.Base.Alternative Yesod.Form.Types.FormResult


-- | Provides for getting input from either GET or POST params without
--   generating HTML forms. For more information, see:
--   <a>http://www.yesodweb.com/book/forms#forms_kinds_of_forms</a>.
module Yesod.Form.Input

-- | Type for a form which parses a value of type <tt>a</tt> with the base
--   monad <tt>m</tt> (usually your <tt>Handler</tt>). Can compose this
--   using its <tt>Applicative</tt> instance.
newtype FormInput m a
FormInput :: (HandlerSite m -> [Text] -> Env -> FileEnv -> m (Either DText a)) -> FormInput m a
[unFormInput] :: FormInput m a -> HandlerSite m -> [Text] -> Env -> FileEnv -> m (Either DText a)

-- | Run a <tt>FormInput</tt> on the GET parameters (i.e., query string).
--   If parsing fails, calls <a>invalidArgs</a>.
runInputGet :: MonadHandler m => FormInput m a -> m a

-- | Run a <tt>FormInput</tt> on the GET parameters (i.e., query string).
--   Does <i>not</i> throw exceptions on failure.
--   
--   Since 1.4.1
runInputGetResult :: MonadHandler m => FormInput m a -> m (FormResult a)

-- | Run a <tt>FormInput</tt> on the POST parameters (i.e., request body).
--   If parsing fails, calls <a>invalidArgs</a>.
runInputPost :: MonadHandler m => FormInput m a -> m a

-- | Run a <tt>FormInput</tt> on the POST parameters (i.e., request body).
--   Does <i>not</i> throw exceptions on failure.
runInputPostResult :: MonadHandler m => FormInput m a -> m (FormResult a)

-- | Promote a <tt>Field</tt> into a <tt>FormInput</tt>, requiring that the
--   value be present and valid.
ireq :: (Monad m, RenderMessage (HandlerSite m) FormMessage) => Field m a -> Text -> FormInput m a

-- | Promote a <tt>Field</tt> into a <tt>FormInput</tt>, with its presence
--   being optional. If the value is present but does not parse correctly,
--   the form will still fail.
iopt :: Monad m => Field m a -> Text -> FormInput m (Maybe a)
instance GHC.Base.Monad m => GHC.Base.Functor (Yesod.Form.Input.FormInput m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Yesod.Form.Input.FormInput m)

module Yesod.Form.I18n.Swedish
swedishFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Spanish
spanishFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Russian
russianFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Portuguese
portugueseFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Norwegian
norwegianBokmÃ¥lFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Korean
koreanFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Japanese
japaneseFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.German
germanFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.French
frenchFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.English
englishFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Dutch
dutchFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Czech
czechFormMessage :: FormMessage -> Text

module Yesod.Form.I18n.Chinese
chineseFormMessage :: FormMessage -> Text

module Yesod.Form.Functions

-- | Get a unique identifier.
newFormIdent :: Monad m => MForm m Text
askParams :: Monad m => MForm m (Maybe Env)
askFiles :: Monad m => MForm m (Maybe FileEnv)
formToAForm :: (HandlerSite m ~ site, Monad m) => MForm m (FormResult a, [FieldView site]) -> AForm m a
aFormToForm :: (Monad m, HandlerSite m ~ site) => AForm m a -> MForm m (FormResult a, [FieldView site] -> [FieldView site])

-- | Converts a monadic form <a>MForm</a> into another monadic form
--   <a>WForm</a>.
mFormToWForm :: (MonadHandler m, HandlerSite m ~ site) => MForm m (a, FieldView site) -> WForm m a

-- | Converts a monadic form <a>WForm</a> into an applicative form
--   <a>AForm</a>.
wFormToAForm :: MonadHandler m => WForm m (FormResult a) -> AForm m a

-- | Converts a monadic form <a>WForm</a> into another monadic form
--   <a>MForm</a>.
wFormToMForm :: (MonadHandler m, HandlerSite m ~ site) => WForm m a -> MForm m (a, [FieldView site])

-- | Converts a form field into monadic form <a>WForm</a>. This field
--   requires a value and will return <a>FormFailure</a> if left empty.
wreq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> Maybe a -> WForm m (FormResult a)

-- | Same as <tt>wreq</tt> but with your own message to be rendered in case
--   the value is not provided.
--   
--   This is useful when you have several required fields on the page and
--   you want to differentiate between which fields were left blank.
--   Otherwise the user sees "Value is required" multiple times, which is
--   ambiguous.
wreqMsg :: (RenderMessage site msg, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> msg -> Maybe a -> WForm m (FormResult a)

-- | Converts a form field into monadic form <a>WForm</a>. This field is
--   optional, i.e. if filled in, it returns 'Just a', if left empty, it
--   returns <a>Nothing</a>. Arguments are the same as for <a>wreq</a>
--   (apart from type of default value).
wopt :: (MonadHandler m, HandlerSite m ~ site) => Field m a -> FieldSettings site -> Maybe (Maybe a) -> WForm m (FormResult (Maybe a))

-- | Converts a form field into monadic form. This field requires a value
--   and will return <a>FormFailure</a> if left empty.
mreq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> Maybe a -> MForm m (FormResult a, FieldView site)

-- | Same as <tt>mreq</tt> but with your own message to be rendered in case
--   the value is not provided.
--   
--   This is useful when you have several required fields on the page and
--   you want to differentiate between which fields were left blank.
--   Otherwise the user sees "Value is required" multiple times, which is
--   ambiguous.
mreqMsg :: (RenderMessage site msg, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> msg -> Maybe a -> MForm m (FormResult a, FieldView site)

-- | Converts a form field into monadic form. This field is optional, i.e.
--   if filled in, it returns 'Just a', if left empty, it returns
--   <a>Nothing</a>. Arguments are the same as for <a>mreq</a> (apart from
--   type of default value).
mopt :: (site ~ HandlerSite m, MonadHandler m) => Field m a -> FieldSettings site -> Maybe (Maybe a) -> MForm m (FormResult (Maybe a), FieldView site)

-- | Applicative equivalent of <a>mreq</a>.
areq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> Maybe a -> AForm m a

-- | Same as <tt>areq</tt> but with your own message to be rendered in case
--   the value is not provided.
--   
--   This is useful when you have several required fields on the page and
--   you want to differentiate between which fields were left blank.
--   Otherwise the user sees "Value is required" multiple times, which is
--   ambiguous.
areqMsg :: (RenderMessage site msg, HandlerSite m ~ site, MonadHandler m) => Field m a -> FieldSettings site -> msg -> Maybe a -> AForm m a

-- | Applicative equivalent of <a>mopt</a>.
aopt :: MonadHandler m => Field m a -> FieldSettings (HandlerSite m) -> Maybe (Maybe a) -> AForm m (Maybe a)

-- | This function is used to both initially render a form and to later
--   extract results from it. Note that, due to CSRF protection and a few
--   other issues, forms submitted via GET and POST are slightly different.
--   As such, be sure to call the relevant function based on how the form
--   will be submitted, <i>not</i> the current request method.
--   
--   For example, a common case is displaying a form on a GET request and
--   having the form submit to a POST page. In such a case, both the GET
--   and POST handlers should use <a>runFormPost</a>.
runFormPost :: (RenderMessage (HandlerSite m) FormMessage, MonadResource m, MonadHandler m) => (Markup -> MForm m (FormResult a, xml)) -> m ((FormResult a, xml), Enctype)
runFormPostNoToken :: MonadHandler m => (Markup -> MForm m a) -> m (a, Enctype)
runFormGet :: MonadHandler m => (Markup -> MForm m a) -> m (a, Enctype)

-- | Similar to <a>runFormPost</a>, except it always ignores the currently
--   available environment. This is necessary in cases like a wizard UI,
--   where a single page will both receive and incoming form and produce a
--   new, blank form. For general usage, you can stick with
--   <tt>runFormPost</tt>.
generateFormPost :: (RenderMessage (HandlerSite m) FormMessage, MonadHandler m) => (Markup -> MForm m (FormResult a, xml)) -> m (xml, Enctype)

-- | Since 1.3.11
generateFormGet' :: MonadHandler m => (Markup -> MForm m (FormResult a, xml)) -> m (xml, Enctype)

-- | <i>Deprecated: Will require RenderMessage in next version of Yesod</i>
generateFormGet :: MonadHandler m => (Markup -> MForm m a) -> m (a, Enctype)

-- | Creates a hidden field on the form that identifies it. This
--   identification is then used to distinguish between <i>missing</i> and
--   <i>wrong</i> form data when a single handler contains more than one
--   form.
--   
--   For instance, if you have the following code on your handler:
--   
--   <pre>
--   ((fooRes, fooWidget), fooEnctype) &lt;- runFormPost fooForm
--   ((barRes, barWidget), barEnctype) &lt;- runFormPost barForm
--   </pre>
--   
--   Then replace it with
--   
--   <pre>
--   ((fooRes, fooWidget), fooEnctype) &lt;- runFormPost $ identifyForm "foo" fooForm
--   ((barRes, barWidget), barEnctype) &lt;- runFormPost $ identifyForm "bar" barForm
--   </pre>
--   
--   Note that it's your responsibility to ensure that the identification
--   strings are unique (using the same one twice on a single handler will
--   not generate any errors). This allows you to create a variable number
--   of forms and still have them work even if their number or order change
--   between the HTML generation and the form submission.
identifyForm :: Monad m => Text -> (Markup -> MForm m (FormResult a, WidgetFor (HandlerSite m) ())) -> Markup -> MForm m (FormResult a, WidgetFor (HandlerSite m) ())
type FormRender m a = AForm m a -> Markup -> MForm m (FormResult a, WidgetFor (HandlerSite m) ())

-- | Render a form into a series of tr tags. Note that, in order to allow
--   you to add extra rows to the table, this function does <i>not</i> wrap
--   up the resulting HTML in a table tag; you must do that yourself.
renderTable :: Monad m => FormRender m a

-- | render a field inside a div
renderDivs :: Monad m => FormRender m a

-- | render a field inside a div, not displaying any label
renderDivsNoLabels :: Monad m => FormRender m a

-- | Deprecated synonym for <a>renderBootstrap2</a>.

-- | <i>Deprecated: Please use the Yesod.Form.Bootstrap3 module.</i>
renderBootstrap :: Monad m => FormRender m a

-- | Render a form using Bootstrap v2-friendly shamlet syntax. If you're
--   using Bootstrap v3, then you should use the functions from module
--   <a>Yesod.Form.Bootstrap3</a>.
--   
--   Sample Hamlet:
--   
--   <pre>
--   &lt;form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}&gt;
--     &lt;fieldset&gt;
--       &lt;legend&gt;_{MsgLegend}
--       $case result
--         $of FormFailure reasons
--           $forall reason &lt;- reasons
--             &lt;div .alert .alert-error&gt;#{reason}
--         $of _
--       ^{formWidget}
--       &lt;div .form-actions&gt;
--         &lt;input .btn .primary type=submit value=_{MsgSubmit}&gt;
--   </pre>
--   
--   Since 1.3.14
renderBootstrap2 :: Monad m => FormRender m a
check :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> Either msg a) -> Field m a -> Field m a

-- | Return the given error message if the predicate is false.
checkBool :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> Bool) -> msg -> Field m a -> Field m a
checkM :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> m (Either msg a)) -> Field m a -> Field m a

-- | Same as <a>checkM</a>, but modifies the datatype.
--   
--   In order to make this work, you must provide a function to convert
--   back from the new datatype to the old one (the second argument to this
--   function).
--   
--   Since 1.1.2
checkMMap :: (Monad m, RenderMessage (HandlerSite m) msg) => (a -> m (Either msg b)) -> (b -> a) -> Field m a -> Field m b

-- | Allows you to overwrite the error message on parse error.
customErrorMessage :: Monad m => SomeMessage (HandlerSite m) -> Field m a -> Field m a

-- | Generate a <a>FieldSettings</a> from the given label.
fieldSettingsLabel :: RenderMessage site msg => msg -> FieldSettings site

-- | A helper function for creating custom fields.
--   
--   This is intended to help with the common case where a single input
--   value is required, such as when parsing a text field.
--   
--   Since 1.1
parseHelper :: (Monad m, RenderMessage site FormMessage) => (Text -> Either FormMessage a) -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))

-- | A generalized version of <a>parseHelper</a>, allowing any type for the
--   message indicating a bad parse.
--   
--   Since 1.3.6
parseHelperGen :: (Monad m, RenderMessage site msg) => (Text -> Either msg a) -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))

-- | Since a <a>Field</a> cannot be a <a>Functor</a>, it is not obvious how
--   to "reuse" a Field on a <tt>newtype</tt> or otherwise equivalent type.
--   This function allows you to convert a <tt>Field m a</tt> to a
--   <tt>Field m b</tt> assuming you provide a bidirectional conversion
--   between the two, through the first two functions.
--   
--   A simple example:
--   
--   <pre>
--   import Data.Monoid
--   sumField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) =&gt; Field m (Sum Int)
--   sumField = convertField Sum getSum intField
--   </pre>
--   
--   Another example, not using a newtype, but instead creating a Lazy Text
--   field:
--   
--   <pre>
--   import qualified Data.Text.Lazy as TL
--   TextField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) =&gt; Field m TL.Text
--   lazyTextField = convertField TL.fromStrict TL.toStrict textField
--   </pre>
--   
--   Since 1.3.16
convertField :: Functor m => (a -> b) -> (b -> a) -> Field m a -> Field m b

-- | Adds a CSS class to the <a>fsAttrs</a> in a <a>FieldSettings</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; addClass "login-form" [("class", "form-control"), ("id", "home-login")]
--   [("class","form-control login-form"),("id","home-login")]
--   </pre>
addClass :: Text -> [(Text, Text)] -> [(Text, Text)]

-- | Removes a CSS class from the <a>fsAttrs</a> in a <a>FieldSettings</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; removeClass "form-control" [("class","form-control login-form"),("id","home-login")]
--   [("class","  login-form"),("id","home-login")]
--   </pre>
removeClass :: Text -> [(Text, Text)] -> [(Text, Text)]


-- | Field functions allow you to easily create and validate forms, cleanly
--   handling the uncertainty of parsing user input.
--   
--   When possible, the field functions use a specific input type (e.g.
--   "number"), allowing supporting browsers to validate the input before
--   form submission. Browsers can also improve usability with this
--   information; for example, mobile browsers might present a specialized
--   keyboard for an input of type "email" or "number".
--   
--   See the Yesod book <a>chapter on forms</a> for a broader overview of
--   forms in Yesod.
module Yesod.Form.Fields
data FormMessage
MsgInvalidInteger :: Text -> FormMessage
MsgInvalidNumber :: Text -> FormMessage
MsgInvalidEntry :: Text -> FormMessage
MsgInvalidUrl :: Text -> FormMessage
MsgInvalidEmail :: Text -> FormMessage
MsgInvalidTimeFormat :: FormMessage
MsgInvalidHour :: Text -> FormMessage
MsgInvalidMinute :: Text -> FormMessage
MsgInvalidSecond :: Text -> FormMessage
MsgInvalidDay :: FormMessage
MsgCsrfWarning :: FormMessage
MsgValueRequired :: FormMessage
MsgInputNotFound :: Text -> FormMessage
MsgSelectNone :: FormMessage
MsgInvalidBool :: Text -> FormMessage
MsgBoolYes :: FormMessage
MsgBoolNo :: FormMessage
MsgDelete :: FormMessage
defaultFormMessage :: FormMessage -> Text

-- | Creates a input with <tt>type="text"</tt>.
textField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates an input with <tt>type="password"</tt>.
passwordField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates a <tt>&lt;textarea&gt;</tt> tag whose returned value is
--   wrapped in a <a>Textarea</a>; see <a>Textarea</a> for details.
textareaField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Textarea

-- | Creates an input with <tt>type="hidden"</tt>; you can use this to
--   store information in a form that users shouldn't see (for example,
--   Yesod stores CSRF tokens in a hidden field).
hiddenField :: (Monad m, PathPiece p, RenderMessage (HandlerSite m) FormMessage) => Field m p

-- | Creates a input with <tt>type="number"</tt> and <tt>step=1</tt>.
intField :: (Monad m, Integral i, RenderMessage (HandlerSite m) FormMessage) => Field m i

-- | Creates an input with <tt>type="date"</tt>, validating the input using
--   the <a>parseDate</a> function.
--   
--   Add the <tt>time</tt> package and import the <a>Data.Time.Calendar</a>
--   module to use this function.
dayField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Day

-- | An alias for <a>timeFieldTypeTime</a>.
timeField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates an input with <tt>type="time"</tt>. <a>Browsers not supporting
--   this type</a> will fallback to a text field, and Yesod will parse the
--   time as described in <a>timeFieldTypeText</a>.
--   
--   Add the <tt>time</tt> package and import the
--   <a>Data.Time.LocalTime</a> module to use this function.
--   
--   Since 1.4.2
timeFieldTypeTime :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates an input with <tt>type="text"</tt>, parsing the time from an
--   [H]H:MM[:SS] format, with an optional AM or PM (if not given, AM is
--   assumed for compatibility with the 24 hour clock system).
--   
--   This function exists for backwards compatibility with the old
--   implementation of <a>timeField</a>, which used to use
--   <tt>type="text"</tt>. Consider using <a>timeField</a> or
--   <a>timeFieldTypeTime</a> for improved UX and validation from the
--   browser.
--   
--   Add the <tt>time</tt> package and import the
--   <a>Data.Time.LocalTime</a> module to use this function.
--   
--   Since 1.4.2
timeFieldTypeText :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates a <tt>&lt;textarea&gt;</tt> tag whose input is sanitized to
--   prevent XSS attacks and is validated for having balanced tags.
htmlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Html

-- | Creates an input with <tt>type="email"</tt>. Yesod will validate the
--   email's correctness according to RFC5322 and canonicalize it by
--   removing comments and whitespace (see <a>Text.Email.Validate</a>).
emailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates an input with <tt>type="email"</tt> with the <a>multiple</a>
--   attribute; browsers might implement this as taking a comma separated
--   list of emails. Each email address is validated as described in
--   <a>emailField</a>.
--   
--   Since 1.3.7
multiEmailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m [Text]

-- | Creates an input with <tt>type="search"</tt>. For <a>browsers without
--   autofocus support</a>, a JS fallback is used if <tt>AutoFocus</tt> is
--   true.
searchField :: Monad m => RenderMessage (HandlerSite m) FormMessage => AutoFocus -> Field m Text
type AutoFocus = Bool

-- | Creates an input with <tt>type="url"</tt>, validating the URL
--   according to RFC3986.
urlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates a input with <tt>type="number"</tt> and <tt>step=any</tt>.
doubleField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Double

-- | Parses a <a>Day</a> from a <a>String</a>.
parseDate :: String -> Either FormMessage Day
parseTime :: Text -> Either FormMessage TimeOfDay

-- | A newtype wrapper around a <a>Text</a> whose <a>ToMarkup</a> instance
--   converts newlines to HTML <tt>&lt;br&gt;</tt> tags.
--   
--   (When text is entered into a <tt>&lt;textarea&gt;</tt>, newline
--   characters are used to separate lines. If this text is then placed
--   verbatim into HTML, the lines won't be separated, thus the need for
--   replacing with <tt>&lt;br&gt;</tt> tags). If you don't need this
--   functionality, simply use <a>unTextarea</a> to access the raw text.
newtype Textarea
Textarea :: Text -> Textarea
[unTextarea] :: Textarea -> Text

-- | Creates a group of radio buttons to answer the question given in the
--   message. Radio buttons are used to allow differentiating between an
--   empty response (<tt>Nothing</tt>) and a no response (<tt>Just
--   False</tt>). Consider using the simpler <a>checkBoxField</a> if you
--   don't need to make this distinction.
--   
--   If this field is optional, the first radio button is labeled
--   "&lt;None&gt;", the second "Yes" and the third "No".
--   
--   If this field is required, the first radio button is labeled "Yes" and
--   the second "No".
--   
--   (Exact label titles will depend on localization).
boolField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool

-- | Creates an input with <tt>type="checkbox"</tt>. While the default
--   <tt><a>boolField</a></tt> implements a radio button so you can
--   differentiate between an empty response (<tt>Nothing</tt>) and a no
--   response (<tt>Just False</tt>), this simpler checkbox field returns an
--   empty response as <tt>Just False</tt>.
--   
--   Note that this makes the field always optional.
checkBoxField :: Monad m => Field m Bool

-- | Creates an input with <tt>type="file"</tt>.
fileField :: Monad m => Field m FileInfo
fileAFormReq :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage) => FieldSettings (HandlerSite m) -> AForm m FileInfo
fileAFormOpt :: MonadHandler m => FieldSettings (HandlerSite m) -> AForm m (Maybe FileInfo)

-- | A helper function for constucting <a>selectField</a>s. You may want to
--   use this when you define your custom <a>selectField</a>s or
--   <a>radioField</a>s.
selectFieldHelper :: (Eq a, RenderMessage site FormMessage) => (Text -> Text -> [(Text, Text)] -> WidgetFor site () -> WidgetFor site ()) -> (Text -> Text -> Bool -> WidgetFor site ()) -> (Text -> Text -> [(Text, Text)] -> Text -> Bool -> Text -> WidgetFor site ()) -> HandlerFor site (OptionList a) -> Field (HandlerFor site) a

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting one option.
--   Example usage:
--   
--   <pre>
--   areq (selectField $ optionsPairs [(MsgValue1, "value1"),(MsgValue2, "value2")]) "Which value?" Nothing
--   </pre>
selectField :: (Eq a, RenderMessage site FormMessage) => HandlerFor site (OptionList a) -> Field (HandlerFor site) a

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting one option.
--   Example usage:
--   
--   <pre>
--   areq (selectFieldList [("Value 1" :: Text, "value1"),("Value 2", "value2")]) "Which value?" Nothing
--   </pre>
selectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) a

-- | Creates an input with <tt>type="radio"</tt> for selecting one option.
radioField :: (Eq a, RenderMessage site FormMessage) => HandlerFor site (OptionList a) -> Field (HandlerFor site) a

-- | Creates an input with <tt>type="radio"</tt> for selecting one option.
radioFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) a

-- | Creates an input with <tt>type="checkbox"</tt> for selecting multiple
--   options.
checkboxesField :: Eq a => HandlerFor site (OptionList a) -> Field (HandlerFor site) [a]

-- | Creates an input with <tt>type="checkbox"</tt> for selecting multiple
--   options.
checkboxesFieldList :: (Eq a, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) [a]

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting multiple options.
multiSelectField :: Eq a => HandlerFor site (OptionList a) -> Field (HandlerFor site) [a]

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting multiple options.
multiSelectFieldList :: (Eq a, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) [a]
data Option a
Option :: Text -> a -> Text -> Option a

-- | The user-facing label.
[optionDisplay] :: Option a -> Text

-- | The Haskell value being selected.
[optionInternalValue] :: Option a -> a

-- | The representation of this value stored in the form.
[optionExternalValue] :: Option a -> Text

-- | A structure holding a list of options. Typically you can use a
--   convenience function like <a>mkOptionList</a> or <a>optionsPairs</a>
--   instead of creating this directly.
data OptionList a
OptionList :: [Option a] -> (Text -> Maybe a) -> OptionList a
[olOptions] :: OptionList a -> [Option a]

-- | A function mapping from the form's value (<a>optionExternalValue</a>)
--   to the selected Haskell value (<a>optionInternalValue</a>).
[olReadExternal] :: OptionList a -> Text -> Maybe a

-- | Creates an <a>OptionList</a>, using a <tt>Map</tt> to implement the
--   <a>olReadExternal</a> function.
mkOptionList :: [Option a] -> OptionList a

-- | Selects a list of <a>Entity</a>s with the given <a>Filter</a> and
--   <a>SelectOpt</a>s. The <tt>(a -&gt; msg)</tt> function is then used to
--   derive the display value for an <a>OptionList</a>. Example usage:
--   
--   <pre>
--   Country
--      name Text
--      deriving Eq -- Must derive Eq
--   </pre>
--   
--   <pre>
--   data CountryForm = CountryForm
--     { country :: Entity Country
--     }
--   
--   countryNameForm :: AForm Handler CountryForm
--   countryNameForm = CountryForm
--           &lt;$&gt; areq (selectField countries) "Which country do you live in?" Nothing
--           where
--             countries = optionsPersist [] [Asc CountryName] countryName
--   </pre>
optionsPersist :: (YesodPersist site, PersistQueryRead backend, PathPiece (Key a), RenderMessage site msg, YesodPersistBackend site ~ backend, PersistRecordBackend a backend) => [Filter a] -> [SelectOpt a] -> (a -> msg) -> HandlerFor site (OptionList (Entity a))

-- | An alternative to <a>optionsPersist</a> which returns just the
--   <a>Key</a> instead of the entire <a>Entity</a>.
--   
--   Since 1.3.2
optionsPersistKey :: (YesodPersist site, PersistQueryRead backend, PathPiece (Key a), RenderMessage site msg, backend ~ YesodPersistBackend site, PersistRecordBackend a backend) => [Filter a] -> [SelectOpt a] -> (a -> msg) -> HandlerFor site (OptionList (Key a))

-- | Creates an <a>OptionList</a> from a list of (display-value, internal
--   value) pairs.
optionsPairs :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => [(msg, a)] -> m (OptionList a)

-- | Creates an <a>OptionList</a> from an <a>Enum</a>, using its
--   <a>Show</a> instance for the user-facing value.
optionsEnum :: (MonadHandler m, Show a, Enum a, Bounded a) => m (OptionList a)
instance Data.String.IsString Yesod.Form.Fields.Textarea
instance Data.Aeson.Types.FromJSON.FromJSON Yesod.Form.Fields.Textarea
instance Data.Aeson.Types.ToJSON.ToJSON Yesod.Form.Fields.Textarea
instance GHC.Classes.Ord Yesod.Form.Fields.Textarea
instance Database.Persist.Class.PersistField.PersistField Yesod.Form.Fields.Textarea
instance GHC.Classes.Eq Yesod.Form.Fields.Textarea
instance GHC.Read.Read Yesod.Form.Fields.Textarea
instance GHC.Show.Show Yesod.Form.Fields.Textarea
instance GHC.Base.Functor Yesod.Form.Fields.OptionList
instance GHC.Base.Functor Yesod.Form.Fields.Option
instance Database.Persist.Sql.Class.PersistFieldSql Yesod.Form.Fields.Textarea
instance Text.Blaze.ToMarkup Yesod.Form.Fields.Textarea


-- | A module providing a means of creating multiple input forms, such as a
--   list of 0 or more recipients.
module Yesod.Form.MassInput

-- | Generate a form that accepts 0 or more values from the user, allowing
--   the user to specify that a new row is necessary.
inputList :: (xml ~ WidgetFor site (), RenderMessage site FormMessage) => Html -> ([[FieldView site]] -> xml) -> (Maybe a -> AForm (HandlerFor site) a) -> Maybe [a] -> AForm (HandlerFor site) [a]
massDivs :: [[FieldView site]] -> WidgetFor site ()
massTable :: [[FieldView site]] -> WidgetFor site ()


-- | Helper functions for creating forms when using <a>Bootstrap 3</a>.
module Yesod.Form.Bootstrap3

-- | Render the given form using Bootstrap v3 conventions.
--   
--   Since: yesod-form 1.3.8
renderBootstrap3 :: Monad m => BootstrapFormLayout -> FormRender m a

-- | The layout used for the bootstrap form.
--   
--   Since: yesod-form 1.3.8
data BootstrapFormLayout

-- | A form with labels and inputs listed vertically. See
--   <a>http://getbootstrap.com/css/#forms-example</a>
BootstrapBasicForm :: BootstrapFormLayout

-- | A form whose <tt>&lt;inputs&gt;</tt> are laid out horizontally
--   (displayed as <tt>inline-block</tt>). For this layout,
--   <tt>&lt;label&gt;</tt>s are still added to the HTML, but are hidden
--   from display. When using this layout, you must add the
--   <tt>form-inline</tt> class to your form tag. See
--   <a>http://getbootstrap.com/css/#forms-inline</a>
BootstrapInlineForm :: BootstrapFormLayout

-- | A form laid out using the Bootstrap grid, with labels in the left
--   column and inputs on the right. When using this layout, you must add
--   the <tt>form-horizontal</tt> class to your form tag. Bootstrap
--   requires additional markup for the submit button for horizontal forms;
--   you can use <a>bootstrapSubmit</a> in your form or write the markup
--   manually. See <a>http://getbootstrap.com/css/#forms-horizontal</a>
BootstrapHorizontalForm :: !BootstrapGridOptions -> !BootstrapGridOptions -> !BootstrapGridOptions -> !BootstrapGridOptions -> BootstrapFormLayout

-- | The left <a>offset</a> of the <tt>&lt;label&gt;</tt>.
[bflLabelOffset] :: BootstrapFormLayout -> !BootstrapGridOptions

-- | The number of grid columns the <tt>&lt;label&gt;</tt> should use.
[bflLabelSize] :: BootstrapFormLayout -> !BootstrapGridOptions

-- | The left <a>offset</a> of the <tt>&lt;input&gt;</tt> from its
--   <tt>&lt;label&gt;</tt>.
[bflInputOffset] :: BootstrapFormLayout -> !BootstrapGridOptions

-- | The number of grid columns the <tt>&lt;input&gt;</tt> should use.
[bflInputSize] :: BootstrapFormLayout -> !BootstrapGridOptions

-- | How many bootstrap grid columns should be taken (see
--   <a>BootstrapFormLayout</a>).
--   
--   Since: yesod-form 1.3.8
data BootstrapGridOptions
ColXs :: !Int -> BootstrapGridOptions
ColSm :: !Int -> BootstrapGridOptions
ColMd :: !Int -> BootstrapGridOptions
ColLg :: !Int -> BootstrapGridOptions

-- | Create a new <a>FieldSettings</a> with the <tt>form-control</tt> class
--   that is required by Bootstrap v3.
--   
--   Since: yesod-form 1.3.8
bfs :: RenderMessage site msg => msg -> FieldSettings site

-- | Add a placeholder attribute to a field. If you need i18n for the
--   placeholder, currently you'll need to do a hack and use
--   <a>getMessageRender</a> manually.
--   
--   Since: yesod-form 1.3.8
withPlaceholder :: Text -> FieldSettings site -> FieldSettings site

-- | Add an autofocus attribute to a field.
--   
--   Since: yesod-form 1.3.8
withAutofocus :: FieldSettings site -> FieldSettings site

-- | Add the <tt>input-lg</tt> CSS class to a field.
--   
--   Since: yesod-form 1.3.8
withLargeInput :: FieldSettings site -> FieldSettings site

-- | Add the <tt>input-sm</tt> CSS class to a field.
--   
--   Since: yesod-form 1.3.8
withSmallInput :: FieldSettings site -> FieldSettings site

-- | A Bootstrap v3 submit button disguised as a field for convenience. For
--   example, if your form currently is:
--   
--   <pre>
--   Person &lt;$&gt; areq textField "Name"    Nothing
--          &lt;*&gt; areq textField "Surname" Nothing
--   </pre>
--   
--   Then just change it to:
--   
--   <pre>
--   Person &lt;$&gt; areq textField "Name"    Nothing
--          &lt;*&gt; areq textField "Surname" Nothing
--          &lt;*  bootstrapSubmit ("Register" :: BootstrapSubmit Text)
--   </pre>
--   
--   (Note that <a>&lt;*</a> is not a typo.)
--   
--   Alternatively, you may also just create the submit button manually as
--   well in order to have more control over its layout.
--   
--   Since: yesod-form 1.3.8
bootstrapSubmit :: (RenderMessage site msg, HandlerSite m ~ site, MonadHandler m) => BootstrapSubmit msg -> AForm m ()

-- | Same as <a>bootstrapSubmit</a> but for monadic forms. This isn't as
--   useful since you're not going to use <a>renderBootstrap3</a> anyway.
--   
--   Since: yesod-form 1.3.8
mbootstrapSubmit :: (RenderMessage site msg, HandlerSite m ~ site, MonadHandler m) => BootstrapSubmit msg -> MForm m (FormResult (), FieldView site)

-- | How the <a>bootstrapSubmit</a> button should be rendered.
--   
--   Since: yesod-form 1.3.8
data BootstrapSubmit msg
BootstrapSubmit :: msg -> Text -> [(Text, Text)] -> BootstrapSubmit msg

-- | The text of the submit button.
[bsValue] :: BootstrapSubmit msg -> msg

-- | Classes added to the <tt>&lt;button&gt;</tt>.
[bsClasses] :: BootstrapSubmit msg -> Text

-- | Attributes added to the <tt>&lt;button&gt;</tt>.
[bsAttrs] :: BootstrapSubmit msg -> [(Text, Text)]
instance GHC.Show.Show msg => GHC.Show.Show (Yesod.Form.Bootstrap3.BootstrapSubmit msg)
instance GHC.Show.Show Yesod.Form.Bootstrap3.BootstrapFormLayout
instance GHC.Show.Show Yesod.Form.Bootstrap3.BootstrapGridOptions
instance GHC.Classes.Ord Yesod.Form.Bootstrap3.BootstrapGridOptions
instance GHC.Classes.Eq Yesod.Form.Bootstrap3.BootstrapGridOptions
instance Data.String.IsString msg => Data.String.IsString (Yesod.Form.Bootstrap3.BootstrapSubmit msg)


-- | Parse forms (and query strings).
module Yesod.Form
data Option a
Option :: Text -> a -> Text -> Option a

-- | The user-facing label.
[optionDisplay] :: Option a -> Text

-- | The Haskell value being selected.
[optionInternalValue] :: Option a -> a

-- | The representation of this value stored in the form.
[optionExternalValue] :: Option a -> Text

-- | A structure holding a list of options. Typically you can use a
--   convenience function like <a>mkOptionList</a> or <a>optionsPairs</a>
--   instead of creating this directly.
data OptionList a
OptionList :: [Option a] -> (Text -> Maybe a) -> OptionList a
[olOptions] :: OptionList a -> [Option a]

-- | A function mapping from the form's value (<a>optionExternalValue</a>)
--   to the selected Haskell value (<a>optionInternalValue</a>).
[olReadExternal] :: OptionList a -> Text -> Maybe a
type AutoFocus = Bool

-- | A newtype wrapper around a <a>Text</a> whose <a>ToMarkup</a> instance
--   converts newlines to HTML <tt>&lt;br&gt;</tt> tags.
--   
--   (When text is entered into a <tt>&lt;textarea&gt;</tt>, newline
--   characters are used to separate lines. If this text is then placed
--   verbatim into HTML, the lines won't be separated, thus the need for
--   replacing with <tt>&lt;br&gt;</tt> tags). If you don't need this
--   functionality, simply use <a>unTextarea</a> to access the raw text.
newtype Textarea
Textarea :: Text -> Textarea
[unTextarea] :: Textarea -> Text
defaultFormMessage :: FormMessage -> Text

-- | Creates a input with <tt>type="number"</tt> and <tt>step=1</tt>.
intField :: (Monad m, Integral i, RenderMessage (HandlerSite m) FormMessage) => Field m i

-- | Creates a input with <tt>type="number"</tt> and <tt>step=any</tt>.
doubleField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Double

-- | Creates an input with <tt>type="date"</tt>, validating the input using
--   the <a>parseDate</a> function.
--   
--   Add the <tt>time</tt> package and import the <a>Data.Time.Calendar</a>
--   module to use this function.
dayField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Day

-- | An alias for <a>timeFieldTypeTime</a>.
timeField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates an input with <tt>type="time"</tt>. <a>Browsers not supporting
--   this type</a> will fallback to a text field, and Yesod will parse the
--   time as described in <a>timeFieldTypeText</a>.
--   
--   Add the <tt>time</tt> package and import the
--   <a>Data.Time.LocalTime</a> module to use this function.
--   
--   Since 1.4.2
timeFieldTypeTime :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates an input with <tt>type="text"</tt>, parsing the time from an
--   [H]H:MM[:SS] format, with an optional AM or PM (if not given, AM is
--   assumed for compatibility with the 24 hour clock system).
--   
--   This function exists for backwards compatibility with the old
--   implementation of <a>timeField</a>, which used to use
--   <tt>type="text"</tt>. Consider using <a>timeField</a> or
--   <a>timeFieldTypeTime</a> for improved UX and validation from the
--   browser.
--   
--   Add the <tt>time</tt> package and import the
--   <a>Data.Time.LocalTime</a> module to use this function.
--   
--   Since 1.4.2
timeFieldTypeText :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay

-- | Creates a <tt>&lt;textarea&gt;</tt> tag whose input is sanitized to
--   prevent XSS attacks and is validated for having balanced tags.
htmlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Html

-- | Creates a <tt>&lt;textarea&gt;</tt> tag whose returned value is
--   wrapped in a <a>Textarea</a>; see <a>Textarea</a> for details.
textareaField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Textarea

-- | Creates an input with <tt>type="hidden"</tt>; you can use this to
--   store information in a form that users shouldn't see (for example,
--   Yesod stores CSRF tokens in a hidden field).
hiddenField :: (Monad m, PathPiece p, RenderMessage (HandlerSite m) FormMessage) => Field m p

-- | Creates a input with <tt>type="text"</tt>.
textField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates an input with <tt>type="password"</tt>.
passwordField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Parses a <a>Day</a> from a <a>String</a>.
parseDate :: String -> Either FormMessage Day
parseTime :: Text -> Either FormMessage TimeOfDay

-- | Creates an input with <tt>type="email"</tt>. Yesod will validate the
--   email's correctness according to RFC5322 and canonicalize it by
--   removing comments and whitespace (see <a>Text.Email.Validate</a>).
emailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates an input with <tt>type="email"</tt> with the <a>multiple</a>
--   attribute; browsers might implement this as taking a comma separated
--   list of emails. Each email address is validated as described in
--   <a>emailField</a>.
--   
--   Since 1.3.7
multiEmailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m [Text]

-- | Creates an input with <tt>type="search"</tt>. For <a>browsers without
--   autofocus support</a>, a JS fallback is used if <tt>AutoFocus</tt> is
--   true.
searchField :: Monad m => RenderMessage (HandlerSite m) FormMessage => AutoFocus -> Field m Text

-- | Creates an input with <tt>type="url"</tt>, validating the URL
--   according to RFC3986.
urlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting one option.
--   Example usage:
--   
--   <pre>
--   areq (selectFieldList [("Value 1" :: Text, "value1"),("Value 2", "value2")]) "Which value?" Nothing
--   </pre>
selectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) a

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting one option.
--   Example usage:
--   
--   <pre>
--   areq (selectField $ optionsPairs [(MsgValue1, "value1"),(MsgValue2, "value2")]) "Which value?" Nothing
--   </pre>
selectField :: (Eq a, RenderMessage site FormMessage) => HandlerFor site (OptionList a) -> Field (HandlerFor site) a

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting multiple options.
multiSelectFieldList :: (Eq a, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) [a]

-- | Creates a <tt>&lt;select&gt;</tt> tag for selecting multiple options.
multiSelectField :: Eq a => HandlerFor site (OptionList a) -> Field (HandlerFor site) [a]

-- | Creates an input with <tt>type="radio"</tt> for selecting one option.
radioFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) a

-- | Creates an input with <tt>type="checkbox"</tt> for selecting multiple
--   options.
checkboxesFieldList :: (Eq a, RenderMessage site msg) => [(msg, a)] -> Field (HandlerFor site) [a]

-- | Creates an input with <tt>type="checkbox"</tt> for selecting multiple
--   options.
checkboxesField :: Eq a => HandlerFor site (OptionList a) -> Field (HandlerFor site) [a]

-- | Creates an input with <tt>type="radio"</tt> for selecting one option.
radioField :: (Eq a, RenderMessage site FormMessage) => HandlerFor site (OptionList a) -> Field (HandlerFor site) a

-- | Creates a group of radio buttons to answer the question given in the
--   message. Radio buttons are used to allow differentiating between an
--   empty response (<tt>Nothing</tt>) and a no response (<tt>Just
--   False</tt>). Consider using the simpler <a>checkBoxField</a> if you
--   don't need to make this distinction.
--   
--   If this field is optional, the first radio button is labeled
--   "&lt;None&gt;", the second "Yes" and the third "No".
--   
--   If this field is required, the first radio button is labeled "Yes" and
--   the second "No".
--   
--   (Exact label titles will depend on localization).
boolField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool

-- | Creates an input with <tt>type="checkbox"</tt>. While the default
--   <tt><a>boolField</a></tt> implements a radio button so you can
--   differentiate between an empty response (<tt>Nothing</tt>) and a no
--   response (<tt>Just False</tt>), this simpler checkbox field returns an
--   empty response as <tt>Just False</tt>.
--   
--   Note that this makes the field always optional.
checkBoxField :: Monad m => Field m Bool

-- | Creates an <a>OptionList</a>, using a <tt>Map</tt> to implement the
--   <a>olReadExternal</a> function.
mkOptionList :: [Option a] -> OptionList a

-- | Creates an <a>OptionList</a> from a list of (display-value, internal
--   value) pairs.
optionsPairs :: (MonadHandler m, RenderMessage (HandlerSite m) msg) => [(msg, a)] -> m (OptionList a)

-- | Creates an <a>OptionList</a> from an <a>Enum</a>, using its
--   <a>Show</a> instance for the user-facing value.
optionsEnum :: (MonadHandler m, Show a, Enum a, Bounded a) => m (OptionList a)

-- | Selects a list of <a>Entity</a>s with the given <a>Filter</a> and
--   <a>SelectOpt</a>s. The <tt>(a -&gt; msg)</tt> function is then used to
--   derive the display value for an <a>OptionList</a>. Example usage:
--   
--   <pre>
--   Country
--      name Text
--      deriving Eq -- Must derive Eq
--   </pre>
--   
--   <pre>
--   data CountryForm = CountryForm
--     { country :: Entity Country
--     }
--   
--   countryNameForm :: AForm Handler CountryForm
--   countryNameForm = CountryForm
--           &lt;$&gt; areq (selectField countries) "Which country do you live in?" Nothing
--           where
--             countries = optionsPersist [] [Asc CountryName] countryName
--   </pre>
optionsPersist :: (YesodPersist site, PersistQueryRead backend, PathPiece (Key a), RenderMessage site msg, YesodPersistBackend site ~ backend, PersistRecordBackend a backend) => [Filter a] -> [SelectOpt a] -> (a -> msg) -> HandlerFor site (OptionList (Entity a))

-- | An alternative to <a>optionsPersist</a> which returns just the
--   <a>Key</a> instead of the entire <a>Entity</a>.
--   
--   Since 1.3.2
optionsPersistKey :: (YesodPersist site, PersistQueryRead backend, PathPiece (Key a), RenderMessage site msg, backend ~ YesodPersistBackend site, PersistRecordBackend a backend) => [Filter a] -> [SelectOpt a] -> (a -> msg) -> HandlerFor site (OptionList (Key a))

-- | A helper function for constucting <a>selectField</a>s. You may want to
--   use this when you define your custom <a>selectField</a>s or
--   <a>radioField</a>s.
selectFieldHelper :: (Eq a, RenderMessage site FormMessage) => (Text -> Text -> [(Text, Text)] -> WidgetFor site () -> WidgetFor site ()) -> (Text -> Text -> Bool -> WidgetFor site ()) -> (Text -> Text -> [(Text, Text)] -> Text -> Bool -> Text -> WidgetFor site ()) -> HandlerFor site (OptionList a) -> Field (HandlerFor site) a

-- | Creates an input with <tt>type="file"</tt>.
fileField :: Monad m => Field m FileInfo
fileAFormReq :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage) => FieldSettings (HandlerSite m) -> AForm m FileInfo
fileAFormOpt :: MonadHandler m => FieldSettings (HandlerSite m) -> AForm m (Maybe FileInfo)


-- | Provide the user with a rich text editor.
--   
--   According to NIC editor homepage it is not actively maintained since
--   June 2012. There is another better alternative â open sourced
--   Summernote editor released under MIT licence. You can use Summernote
--   in your Yesod forms via separately distributed
--   <a>yesod-form-richtext</a> package.
module Yesod.Form.Nic
class Yesod a => YesodNic a

-- | NIC Editor Javascript file.
urlNicEdit :: YesodNic a => a -> Either (Route a) Text
nicHtmlField :: YesodNic site => Field (HandlerFor site) Html


-- | Some fields spiced up with jQuery UI.
module Yesod.Form.Jquery
class YesodJquery a

-- | The jQuery Javascript file. Note that in upgrades to this library, the
--   version of jQuery referenced, or where it is downloaded from, may be
--   changed without warning. If you are relying on a specific version of
--   jQuery, you should give an explicit URL instead of relying on the
--   default value.
--   
--   Currently, the default value is jQuery 1.7 from Google's CDN.
urlJqueryJs :: YesodJquery a => a -> Either (Route a) Text

-- | The jQuery UI 1.8 Javascript file.
urlJqueryUiJs :: YesodJquery a => a -> Either (Route a) Text

-- | The jQuery UI 1.8 CSS file; defaults to cupertino theme.
urlJqueryUiCss :: YesodJquery a => a -> Either (Route a) Text

-- | jQuery UI time picker add-on.
urlJqueryUiDateTimePicker :: YesodJquery a => a -> Either (Route a) Text
jqueryDayField :: (RenderMessage site FormMessage, YesodJquery site) => JqueryDaySettings -> Field (HandlerFor site) Day

-- | Use jQuery's datepicker as the underlying implementation.
--   
--   Since 1.4.3
jqueryDatePickerDayField :: (RenderMessage site FormMessage, YesodJquery site) => JqueryDaySettings -> Field (HandlerFor site) Day
jqueryAutocompleteField :: (RenderMessage site FormMessage, YesodJquery site) => Route site -> Field (HandlerFor site) Text
jqueryAutocompleteField' :: (RenderMessage site FormMessage, YesodJquery site) => Int -> Route site -> Field (HandlerFor site) Text

-- | Gets the Google hosted jQuery UI 1.8 CSS file with the given theme.
googleHostedJqueryUiCss :: Text -> Text
data JqueryDaySettings
JqueryDaySettings :: Bool -> Bool -> String -> Either Int (Int, Int) -> JqueryDaySettings
[jdsChangeMonth] :: JqueryDaySettings -> Bool
[jdsChangeYear] :: JqueryDaySettings -> Bool
[jdsYearRange] :: JqueryDaySettings -> String
[jdsNumberOfMonths] :: JqueryDaySettings -> Either Int (Int, Int)

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a
instance Data.Default.Class.Default Yesod.Form.Jquery.JqueryDaySettings
